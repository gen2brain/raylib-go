// Code generated by ./internal/cmd/genraymath DO NOT EDIT.

package rl

import (
  "math"
  "testing"
  "time"
)


{{ range . -}}
{{ if .SkipTest }}{{ continue }}{{ end }}
func Benchmark{{ .Name }}(b *testing.B) {
  {{- template "quickvars" . }}
  var (
    perCCall time.Duration
    perGoCall time.Duration
  )
  b.Run("c", func(b *testing.B) {
    for i := 0; i < b.N; i++ {
      c{{.Name}}({{ template "testargs" . }})
    }
    perCCall = b.Elapsed() / time.Duration(b.N)
  })
  b.Run("go", func(b *testing.B) {
    for i := 0; i < b.N; i++ {
      {{.Name}}({{ template "testargs" . }})
    }
    perGoCall = b.Elapsed() / time.Duration(b.N)
  })
  if perCCall < perGoCall {
    b.Log("Go slower than C")
  }
}

{{if .Params -}}
func Fuzz{{ .Name }}(f *testing.F) {
  {{ template "fuzzcorpus" . }}
  f.Fuzz(func(t *testing.T, {{ template "fuzzparams" . }}) {
    {{- template "fuzzvars" . }}
    want := c{{.Name}}({{ template "testargs" . }})
    got := {{.Name}}({{ template "testargs" . }})
    if {{ .TestNotEqual "want" "got" }} {
      t.Errorf("got %v; want %v", got, want)
    }
  })
}
{{ else }}
func Test{{ .Name }}(t *testing.T) {
  want := c{{.Name}}()
  got := {{.Name}}()
  if {{ .TestNotEqual "want" "got" }} {
    t.Errorf("got %v; want %v", got, want)
  }
}
{{ end -}}
{{ end }}

// helpers

func testFloat32Equals(a, b float32, epsilon float64) bool {
  if math.IsNaN(float64(a)) && math.IsNaN(float64(b)) {
    return true
  }
  if math.IsInf(float64(a), 1) && math.IsInf(float64(b), 1) {
    return true
  }
  if math.IsInf(float64(a), -1) && math.IsInf(float64(b), -1) {
    return true
  }
  return math.Abs(float64(a-b)) <= epsilon*math.Max(1.0, math.Max(math.Abs(float64(a)), math.Abs(float64(b))))
}

func testFloat32SliceEquals(a, b []float32, epsilon float64) bool {
  if len(a) != len(b) {
    return false
  }
  for i := range a {
    if !testFloat32Equals(a[i], b[i], epsilon) {
      return false
    }
  }
  return true
}

func testVector2Equals(a, b Vector2, epsilon float64) bool {
  return testFloat32Equals(a.X, b.X, epsilon) &&
     testFloat32Equals(a.Y, b.Y, epsilon)
}

func testVector3Equals(a, b Vector3, epsilon float64) bool {
  return testFloat32Equals(a.X, b.X, epsilon) &&
     testFloat32Equals(a.Y, b.Y, epsilon) &&
     testFloat32Equals(a.Z, b.Z, epsilon)
}

func testQuaternionEquals(a, b Quaternion, epsilon float64) bool {
  return testFloat32Equals(a.X, b.X, epsilon) &&
     testFloat32Equals(a.Y, b.Y, epsilon) &&
     testFloat32Equals(a.Z, b.Z, epsilon) &&
     testFloat32Equals(a.W, b.W, epsilon)
}

func testMatrixEquals(a, b Matrix, epsilon float64) bool {
  return testFloat32Equals(a.M0, b.M0, epsilon) &&
     testFloat32Equals(a.M1, b.M1, epsilon) &&
     testFloat32Equals(a.M2, b.M2, epsilon) &&
     testFloat32Equals(a.M3, b.M3, epsilon) &&
     testFloat32Equals(a.M4, b.M4, epsilon) &&
     testFloat32Equals(a.M5, b.M5, epsilon) &&
     testFloat32Equals(a.M6, b.M6, epsilon) &&
     testFloat32Equals(a.M7, b.M7, epsilon) &&
     testFloat32Equals(a.M8, b.M8, epsilon) &&
     testFloat32Equals(a.M9, b.M9, epsilon) &&
     testFloat32Equals(a.M10, b.M10, epsilon) &&
     testFloat32Equals(a.M11, b.M11, epsilon) &&
     testFloat32Equals(a.M12, b.M12, epsilon) &&
     testFloat32Equals(a.M13, b.M13, epsilon) &&
     testFloat32Equals(a.M14, b.M14, epsilon) &&
     testFloat32Equals(a.M15, b.M15, epsilon)
}
