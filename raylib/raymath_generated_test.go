// Code generated by ./internal/cmd/genraymath DO NOT EDIT.

package rl

import (
	"math"
	"testing"
	"time"
)

func BenchmarkClamp(b *testing.B) {
	value := float32(1)
	min := float32(2)
	max := float32(3)
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cClamp(value, min, max)
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			Clamp(value, min, max)
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func FuzzClamp(f *testing.F) {
	f.Add(
		float32(1),
		float32(2),
		float32(3),
	)
	f.Fuzz(func(t *testing.T,
		value float32,
		min float32,
		max float32,
	) {
		want := cClamp(value, min, max)
		got := Clamp(value, min, max)
		if !testFloat32Equals(want, got) {
			t.Errorf("got %v; want %v", got, want)
		}
	})
}

func BenchmarkFloatEquals(b *testing.B) {
	x := float32(1)
	y := float32(2)
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cFloatEquals(x, y)
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			FloatEquals(x, y)
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func FuzzFloatEquals(f *testing.F) {
	f.Add(
		float32(1),
		float32(2),
	)
	f.Fuzz(func(t *testing.T,
		x float32,
		y float32,
	) {
		want := cFloatEquals(x, y)
		got := FloatEquals(x, y)
		if want != got {
			t.Errorf("got %v; want %v", got, want)
		}
	})
}

func BenchmarkLerp(b *testing.B) {
	start := float32(1)
	end := float32(2)
	amount := float32(3)
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cLerp(start, end, amount)
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			Lerp(start, end, amount)
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func FuzzLerp(f *testing.F) {
	f.Add(
		float32(1),
		float32(2),
		float32(3),
	)
	f.Fuzz(func(t *testing.T,
		start float32,
		end float32,
		amount float32,
	) {
		want := cLerp(start, end, amount)
		got := Lerp(start, end, amount)
		if !testFloat32Equals(want, got) {
			t.Errorf("got %v; want %v", got, want)
		}
	})
}

func BenchmarkMatrixAdd(b *testing.B) {
	left := NewMatrix(1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4)
	right := NewMatrix(1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4)
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cMatrixAdd(left, right)
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			MatrixAdd(left, right)
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func FuzzMatrixAdd(f *testing.F) {
	f.Add(
		float32(1), float32(2), float32(3), float32(4),
		float32(1), float32(2), float32(3), float32(4),
		float32(1), float32(2), float32(3), float32(4),
		float32(1), float32(2), float32(3), float32(4),
		float32(1), float32(2), float32(3), float32(4),
		float32(1), float32(2), float32(3), float32(4),
		float32(1), float32(2), float32(3), float32(4),
		float32(1), float32(2), float32(3), float32(4),
	)
	f.Fuzz(func(t *testing.T,
		leftM0, leftM4, leftM8, leftM12,
		leftM1, leftM5, leftM9, leftM13,
		leftM2, leftM6, leftM10, leftM14,
		leftM3, leftM7, leftM11, leftM15 float32,
		rightM0, rightM4, rightM8, rightM12,
		rightM1, rightM5, rightM9, rightM13,
		rightM2, rightM6, rightM10, rightM14,
		rightM3, rightM7, rightM11, rightM15 float32,
	) {
		left := NewMatrix(
			leftM0, leftM4, leftM8, leftM12,
			leftM1, leftM5, leftM9, leftM13,
			leftM2, leftM6, leftM10, leftM14,
			leftM3, leftM7, leftM11, leftM15,
		)
		right := NewMatrix(
			rightM0, rightM4, rightM8, rightM12,
			rightM1, rightM5, rightM9, rightM13,
			rightM2, rightM6, rightM10, rightM14,
			rightM3, rightM7, rightM11, rightM15,
		)
		want := cMatrixAdd(left, right)
		got := MatrixAdd(left, right)
		if !testMatrixEquals(want, got) {
			t.Errorf("got %v; want %v", got, want)
		}
	})
}

func BenchmarkMatrixDeterminant(b *testing.B) {
	mat := NewMatrix(1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4)
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cMatrixDeterminant(mat)
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			MatrixDeterminant(mat)
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func FuzzMatrixDeterminant(f *testing.F) {
	f.Add(
		float32(1), float32(2), float32(3), float32(4),
		float32(1), float32(2), float32(3), float32(4),
		float32(1), float32(2), float32(3), float32(4),
		float32(1), float32(2), float32(3), float32(4),
	)
	f.Fuzz(func(t *testing.T,
		matM0, matM4, matM8, matM12,
		matM1, matM5, matM9, matM13,
		matM2, matM6, matM10, matM14,
		matM3, matM7, matM11, matM15 float32,
	) {
		mat := NewMatrix(
			matM0, matM4, matM8, matM12,
			matM1, matM5, matM9, matM13,
			matM2, matM6, matM10, matM14,
			matM3, matM7, matM11, matM15,
		)
		want := cMatrixDeterminant(mat)
		got := MatrixDeterminant(mat)
		if !testFloat32Equals(want, got) {
			t.Errorf("got %v; want %v", got, want)
		}
	})
}

func BenchmarkMatrixFrustum(b *testing.B) {
	left := float32(1)
	right := float32(2)
	bottom := float32(3)
	top := float32(4)
	nearPlane := float32(5)
	farPlane := float32(6)
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cMatrixFrustum(left, right, bottom, top, nearPlane, farPlane)
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			MatrixFrustum(left, right, bottom, top, nearPlane, farPlane)
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func FuzzMatrixFrustum(f *testing.F) {
	f.Add(
		float32(1),
		float32(2),
		float32(3),
		float32(4),
		float32(5),
		float32(6),
	)
	f.Fuzz(func(t *testing.T,
		left float32,
		right float32,
		bottom float32,
		top float32,
		nearPlane float32,
		farPlane float32,
	) {
		want := cMatrixFrustum(left, right, bottom, top, nearPlane, farPlane)
		got := MatrixFrustum(left, right, bottom, top, nearPlane, farPlane)
		if !testMatrixEquals(want, got) {
			t.Errorf("got %v; want %v", got, want)
		}
	})
}

func BenchmarkMatrixIdentity(b *testing.B) {
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cMatrixIdentity()
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			MatrixIdentity()
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func TestMatrixIdentity(t *testing.T) {
	want := cMatrixIdentity()
	got := MatrixIdentity()
	if !testMatrixEquals(want, got) {
		t.Errorf("got %v; want %v", got, want)
	}
}

func BenchmarkMatrixInvert(b *testing.B) {
	mat := NewMatrix(1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4)
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cMatrixInvert(mat)
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			MatrixInvert(mat)
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func FuzzMatrixInvert(f *testing.F) {
	f.Add(
		float32(1), float32(2), float32(3), float32(4),
		float32(1), float32(2), float32(3), float32(4),
		float32(1), float32(2), float32(3), float32(4),
		float32(1), float32(2), float32(3), float32(4),
	)
	f.Fuzz(func(t *testing.T,
		matM0, matM4, matM8, matM12,
		matM1, matM5, matM9, matM13,
		matM2, matM6, matM10, matM14,
		matM3, matM7, matM11, matM15 float32,
	) {
		mat := NewMatrix(
			matM0, matM4, matM8, matM12,
			matM1, matM5, matM9, matM13,
			matM2, matM6, matM10, matM14,
			matM3, matM7, matM11, matM15,
		)
		want := cMatrixInvert(mat)
		got := MatrixInvert(mat)
		if !testMatrixEquals(want, got) {
			t.Errorf("got %v; want %v", got, want)
		}
	})
}

func BenchmarkMatrixLookAt(b *testing.B) {
	eye := NewVector3(1, 2, 3)
	target := NewVector3(1, 2, 3)
	up := NewVector3(1, 2, 3)
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cMatrixLookAt(eye, target, up)
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			MatrixLookAt(eye, target, up)
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func FuzzMatrixLookAt(f *testing.F) {
	f.Add(
		float32(1), float32(2), float32(3),
		float32(1), float32(2), float32(3),
		float32(1), float32(2), float32(3),
	)
	f.Fuzz(func(t *testing.T,
		eyeX, eyeY, eyeZ float32,
		targetX, targetY, targetZ float32,
		upX, upY, upZ float32,
	) {
		eye := NewVector3(eyeX, eyeY, eyeZ)
		target := NewVector3(targetX, targetY, targetZ)
		up := NewVector3(upX, upY, upZ)
		want := cMatrixLookAt(eye, target, up)
		got := MatrixLookAt(eye, target, up)
		if !testMatrixEquals(want, got) {
			t.Errorf("got %v; want %v", got, want)
		}
	})
}

func BenchmarkMatrixMultiply(b *testing.B) {
	left := NewMatrix(1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4)
	right := NewMatrix(1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4)
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cMatrixMultiply(left, right)
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			MatrixMultiply(left, right)
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func FuzzMatrixMultiply(f *testing.F) {
	f.Add(
		float32(1), float32(2), float32(3), float32(4),
		float32(1), float32(2), float32(3), float32(4),
		float32(1), float32(2), float32(3), float32(4),
		float32(1), float32(2), float32(3), float32(4),
		float32(1), float32(2), float32(3), float32(4),
		float32(1), float32(2), float32(3), float32(4),
		float32(1), float32(2), float32(3), float32(4),
		float32(1), float32(2), float32(3), float32(4),
	)
	f.Fuzz(func(t *testing.T,
		leftM0, leftM4, leftM8, leftM12,
		leftM1, leftM5, leftM9, leftM13,
		leftM2, leftM6, leftM10, leftM14,
		leftM3, leftM7, leftM11, leftM15 float32,
		rightM0, rightM4, rightM8, rightM12,
		rightM1, rightM5, rightM9, rightM13,
		rightM2, rightM6, rightM10, rightM14,
		rightM3, rightM7, rightM11, rightM15 float32,
	) {
		left := NewMatrix(
			leftM0, leftM4, leftM8, leftM12,
			leftM1, leftM5, leftM9, leftM13,
			leftM2, leftM6, leftM10, leftM14,
			leftM3, leftM7, leftM11, leftM15,
		)
		right := NewMatrix(
			rightM0, rightM4, rightM8, rightM12,
			rightM1, rightM5, rightM9, rightM13,
			rightM2, rightM6, rightM10, rightM14,
			rightM3, rightM7, rightM11, rightM15,
		)
		want := cMatrixMultiply(left, right)
		got := MatrixMultiply(left, right)
		if !testMatrixEquals(want, got) {
			t.Errorf("got %v; want %v", got, want)
		}
	})
}

func BenchmarkMatrixOrtho(b *testing.B) {
	left := float32(1)
	right := float32(2)
	bottom := float32(3)
	top := float32(4)
	near := float32(5)
	far := float32(6)
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cMatrixOrtho(left, right, bottom, top, near, far)
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			MatrixOrtho(left, right, bottom, top, near, far)
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func FuzzMatrixOrtho(f *testing.F) {
	f.Add(
		float32(1),
		float32(2),
		float32(3),
		float32(4),
		float32(5),
		float32(6),
	)
	f.Fuzz(func(t *testing.T,
		left float32,
		right float32,
		bottom float32,
		top float32,
		near float32,
		far float32,
	) {
		want := cMatrixOrtho(left, right, bottom, top, near, far)
		got := MatrixOrtho(left, right, bottom, top, near, far)
		if !testMatrixEquals(want, got) {
			t.Errorf("got %v; want %v", got, want)
		}
	})
}

func BenchmarkMatrixPerspective(b *testing.B) {
	fovY := float32(1)
	aspect := float32(2)
	nearPlane := float32(3)
	farPlane := float32(4)
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cMatrixPerspective(fovY, aspect, nearPlane, farPlane)
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			MatrixPerspective(fovY, aspect, nearPlane, farPlane)
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func FuzzMatrixPerspective(f *testing.F) {
	f.Add(
		float32(1),
		float32(2),
		float32(3),
		float32(4),
	)
	f.Fuzz(func(t *testing.T,
		fovY float32,
		aspect float32,
		nearPlane float32,
		farPlane float32,
	) {
		want := cMatrixPerspective(fovY, aspect, nearPlane, farPlane)
		got := MatrixPerspective(fovY, aspect, nearPlane, farPlane)
		if !testMatrixEquals(want, got) {
			t.Errorf("got %v; want %v", got, want)
		}
	})
}

func BenchmarkMatrixRotate(b *testing.B) {
	axis := NewVector3(1, 2, 3)
	angle := float32(1)
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cMatrixRotate(axis, angle)
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			MatrixRotate(axis, angle)
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func FuzzMatrixRotate(f *testing.F) {
	f.Add(
		float32(1), float32(2), float32(3),
		float32(1),
	)
	f.Fuzz(func(t *testing.T,
		axisX, axisY, axisZ float32,
		angle float32,
	) {
		axis := NewVector3(axisX, axisY, axisZ)
		want := cMatrixRotate(axis, angle)
		got := MatrixRotate(axis, angle)
		if !testMatrixEquals(want, got) {
			t.Errorf("got %v; want %v", got, want)
		}
	})
}

func BenchmarkMatrixRotateX(b *testing.B) {
	angle := float32(1)
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cMatrixRotateX(angle)
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			MatrixRotateX(angle)
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func FuzzMatrixRotateX(f *testing.F) {
	f.Add(
		float32(1),
	)
	f.Fuzz(func(t *testing.T,
		angle float32,
	) {
		want := cMatrixRotateX(angle)
		got := MatrixRotateX(angle)
		if !testMatrixEquals(want, got) {
			t.Errorf("got %v; want %v", got, want)
		}
	})
}

func BenchmarkMatrixRotateXYZ(b *testing.B) {
	angle := NewVector3(1, 2, 3)
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cMatrixRotateXYZ(angle)
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			MatrixRotateXYZ(angle)
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func FuzzMatrixRotateXYZ(f *testing.F) {
	f.Add(
		float32(1), float32(2), float32(3),
	)
	f.Fuzz(func(t *testing.T,
		angleX, angleY, angleZ float32,
	) {
		angle := NewVector3(angleX, angleY, angleZ)
		want := cMatrixRotateXYZ(angle)
		got := MatrixRotateXYZ(angle)
		if !testMatrixEquals(want, got) {
			t.Errorf("got %v; want %v", got, want)
		}
	})
}

func BenchmarkMatrixRotateY(b *testing.B) {
	angle := float32(1)
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cMatrixRotateY(angle)
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			MatrixRotateY(angle)
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func FuzzMatrixRotateY(f *testing.F) {
	f.Add(
		float32(1),
	)
	f.Fuzz(func(t *testing.T,
		angle float32,
	) {
		want := cMatrixRotateY(angle)
		got := MatrixRotateY(angle)
		if !testMatrixEquals(want, got) {
			t.Errorf("got %v; want %v", got, want)
		}
	})
}

func BenchmarkMatrixRotateZ(b *testing.B) {
	angle := float32(1)
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cMatrixRotateZ(angle)
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			MatrixRotateZ(angle)
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func FuzzMatrixRotateZ(f *testing.F) {
	f.Add(
		float32(1),
	)
	f.Fuzz(func(t *testing.T,
		angle float32,
	) {
		want := cMatrixRotateZ(angle)
		got := MatrixRotateZ(angle)
		if !testMatrixEquals(want, got) {
			t.Errorf("got %v; want %v", got, want)
		}
	})
}

func BenchmarkMatrixRotateZYX(b *testing.B) {
	angle := NewVector3(1, 2, 3)
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cMatrixRotateZYX(angle)
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			MatrixRotateZYX(angle)
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func FuzzMatrixRotateZYX(f *testing.F) {
	f.Add(
		float32(1), float32(2), float32(3),
	)
	f.Fuzz(func(t *testing.T,
		angleX, angleY, angleZ float32,
	) {
		angle := NewVector3(angleX, angleY, angleZ)
		want := cMatrixRotateZYX(angle)
		got := MatrixRotateZYX(angle)
		if !testMatrixEquals(want, got) {
			t.Errorf("got %v; want %v", got, want)
		}
	})
}

func BenchmarkMatrixScale(b *testing.B) {
	x := float32(1)
	y := float32(2)
	z := float32(3)
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cMatrixScale(x, y, z)
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			MatrixScale(x, y, z)
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func FuzzMatrixScale(f *testing.F) {
	f.Add(
		float32(1),
		float32(2),
		float32(3),
	)
	f.Fuzz(func(t *testing.T,
		x float32,
		y float32,
		z float32,
	) {
		want := cMatrixScale(x, y, z)
		got := MatrixScale(x, y, z)
		if !testMatrixEquals(want, got) {
			t.Errorf("got %v; want %v", got, want)
		}
	})
}

func BenchmarkMatrixSubtract(b *testing.B) {
	left := NewMatrix(1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4)
	right := NewMatrix(1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4)
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cMatrixSubtract(left, right)
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			MatrixSubtract(left, right)
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func FuzzMatrixSubtract(f *testing.F) {
	f.Add(
		float32(1), float32(2), float32(3), float32(4),
		float32(1), float32(2), float32(3), float32(4),
		float32(1), float32(2), float32(3), float32(4),
		float32(1), float32(2), float32(3), float32(4),
		float32(1), float32(2), float32(3), float32(4),
		float32(1), float32(2), float32(3), float32(4),
		float32(1), float32(2), float32(3), float32(4),
		float32(1), float32(2), float32(3), float32(4),
	)
	f.Fuzz(func(t *testing.T,
		leftM0, leftM4, leftM8, leftM12,
		leftM1, leftM5, leftM9, leftM13,
		leftM2, leftM6, leftM10, leftM14,
		leftM3, leftM7, leftM11, leftM15 float32,
		rightM0, rightM4, rightM8, rightM12,
		rightM1, rightM5, rightM9, rightM13,
		rightM2, rightM6, rightM10, rightM14,
		rightM3, rightM7, rightM11, rightM15 float32,
	) {
		left := NewMatrix(
			leftM0, leftM4, leftM8, leftM12,
			leftM1, leftM5, leftM9, leftM13,
			leftM2, leftM6, leftM10, leftM14,
			leftM3, leftM7, leftM11, leftM15,
		)
		right := NewMatrix(
			rightM0, rightM4, rightM8, rightM12,
			rightM1, rightM5, rightM9, rightM13,
			rightM2, rightM6, rightM10, rightM14,
			rightM3, rightM7, rightM11, rightM15,
		)
		want := cMatrixSubtract(left, right)
		got := MatrixSubtract(left, right)
		if !testMatrixEquals(want, got) {
			t.Errorf("got %v; want %v", got, want)
		}
	})
}

func BenchmarkMatrixToFloatV(b *testing.B) {
	mat := NewMatrix(1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4)
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cMatrixToFloatV(mat)
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			MatrixToFloatV(mat)
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func FuzzMatrixToFloatV(f *testing.F) {
	f.Add(
		float32(1), float32(2), float32(3), float32(4),
		float32(1), float32(2), float32(3), float32(4),
		float32(1), float32(2), float32(3), float32(4),
		float32(1), float32(2), float32(3), float32(4),
	)
	f.Fuzz(func(t *testing.T,
		matM0, matM4, matM8, matM12,
		matM1, matM5, matM9, matM13,
		matM2, matM6, matM10, matM14,
		matM3, matM7, matM11, matM15 float32,
	) {
		mat := NewMatrix(
			matM0, matM4, matM8, matM12,
			matM1, matM5, matM9, matM13,
			matM2, matM6, matM10, matM14,
			matM3, matM7, matM11, matM15,
		)
		want := cMatrixToFloatV(mat)
		got := MatrixToFloatV(mat)
		if !testFloat32SliceEquals(want[:], got[:]) {
			t.Errorf("got %v; want %v", got, want)
		}
	})
}

func BenchmarkMatrixTrace(b *testing.B) {
	mat := NewMatrix(1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4)
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cMatrixTrace(mat)
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			MatrixTrace(mat)
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func FuzzMatrixTrace(f *testing.F) {
	f.Add(
		float32(1), float32(2), float32(3), float32(4),
		float32(1), float32(2), float32(3), float32(4),
		float32(1), float32(2), float32(3), float32(4),
		float32(1), float32(2), float32(3), float32(4),
	)
	f.Fuzz(func(t *testing.T,
		matM0, matM4, matM8, matM12,
		matM1, matM5, matM9, matM13,
		matM2, matM6, matM10, matM14,
		matM3, matM7, matM11, matM15 float32,
	) {
		mat := NewMatrix(
			matM0, matM4, matM8, matM12,
			matM1, matM5, matM9, matM13,
			matM2, matM6, matM10, matM14,
			matM3, matM7, matM11, matM15,
		)
		want := cMatrixTrace(mat)
		got := MatrixTrace(mat)
		if !testFloat32Equals(want, got) {
			t.Errorf("got %v; want %v", got, want)
		}
	})
}

func BenchmarkMatrixTranslate(b *testing.B) {
	x := float32(1)
	y := float32(2)
	z := float32(3)
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cMatrixTranslate(x, y, z)
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			MatrixTranslate(x, y, z)
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func FuzzMatrixTranslate(f *testing.F) {
	f.Add(
		float32(1),
		float32(2),
		float32(3),
	)
	f.Fuzz(func(t *testing.T,
		x float32,
		y float32,
		z float32,
	) {
		want := cMatrixTranslate(x, y, z)
		got := MatrixTranslate(x, y, z)
		if !testMatrixEquals(want, got) {
			t.Errorf("got %v; want %v", got, want)
		}
	})
}

func BenchmarkMatrixTranspose(b *testing.B) {
	mat := NewMatrix(1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4)
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cMatrixTranspose(mat)
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			MatrixTranspose(mat)
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func FuzzMatrixTranspose(f *testing.F) {
	f.Add(
		float32(1), float32(2), float32(3), float32(4),
		float32(1), float32(2), float32(3), float32(4),
		float32(1), float32(2), float32(3), float32(4),
		float32(1), float32(2), float32(3), float32(4),
	)
	f.Fuzz(func(t *testing.T,
		matM0, matM4, matM8, matM12,
		matM1, matM5, matM9, matM13,
		matM2, matM6, matM10, matM14,
		matM3, matM7, matM11, matM15 float32,
	) {
		mat := NewMatrix(
			matM0, matM4, matM8, matM12,
			matM1, matM5, matM9, matM13,
			matM2, matM6, matM10, matM14,
			matM3, matM7, matM11, matM15,
		)
		want := cMatrixTranspose(mat)
		got := MatrixTranspose(mat)
		if !testMatrixEquals(want, got) {
			t.Errorf("got %v; want %v", got, want)
		}
	})
}

func BenchmarkNormalize(b *testing.B) {
	value := float32(1)
	start := float32(2)
	end := float32(3)
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cNormalize(value, start, end)
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			Normalize(value, start, end)
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func FuzzNormalize(f *testing.F) {
	f.Add(
		float32(1),
		float32(2),
		float32(3),
	)
	f.Fuzz(func(t *testing.T,
		value float32,
		start float32,
		end float32,
	) {
		want := cNormalize(value, start, end)
		got := Normalize(value, start, end)
		if !testFloat32Equals(want, got) {
			t.Errorf("got %v; want %v", got, want)
		}
	})
}

func BenchmarkQuaternionAdd(b *testing.B) {
	q1 := NewQuaternion(1, 2, 3, 4)
	q2 := NewQuaternion(1, 2, 3, 4)
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cQuaternionAdd(q1, q2)
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			QuaternionAdd(q1, q2)
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func FuzzQuaternionAdd(f *testing.F) {
	f.Add(
		float32(1), float32(2), float32(3), float32(4),
		float32(1), float32(2), float32(3), float32(4),
	)
	f.Fuzz(func(t *testing.T,
		q1X, q1Y, q1Z, q1W float32,
		q2X, q2Y, q2Z, q2W float32,
	) {
		q1 := NewQuaternion(q1X, q1Y, q1Z, q1W)
		q2 := NewQuaternion(q2X, q2Y, q2Z, q2W)
		want := cQuaternionAdd(q1, q2)
		got := QuaternionAdd(q1, q2)
		if !testQuaternionEquals(want, got) {
			t.Errorf("got %v; want %v", got, want)
		}
	})
}

func BenchmarkQuaternionAddValue(b *testing.B) {
	q := NewQuaternion(1, 2, 3, 4)
	add := float32(1)
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cQuaternionAddValue(q, add)
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			QuaternionAddValue(q, add)
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func FuzzQuaternionAddValue(f *testing.F) {
	f.Add(
		float32(1), float32(2), float32(3), float32(4),
		float32(1),
	)
	f.Fuzz(func(t *testing.T,
		qX, qY, qZ, qW float32,
		add float32,
	) {
		q := NewQuaternion(qX, qY, qZ, qW)
		want := cQuaternionAddValue(q, add)
		got := QuaternionAddValue(q, add)
		if !testQuaternionEquals(want, got) {
			t.Errorf("got %v; want %v", got, want)
		}
	})
}

func BenchmarkQuaternionDivide(b *testing.B) {
	q1 := NewQuaternion(1, 2, 3, 4)
	q2 := NewQuaternion(1, 2, 3, 4)
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cQuaternionDivide(q1, q2)
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			QuaternionDivide(q1, q2)
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func FuzzQuaternionDivide(f *testing.F) {
	f.Add(
		float32(1), float32(2), float32(3), float32(4),
		float32(1), float32(2), float32(3), float32(4),
	)
	f.Fuzz(func(t *testing.T,
		q1X, q1Y, q1Z, q1W float32,
		q2X, q2Y, q2Z, q2W float32,
	) {
		q1 := NewQuaternion(q1X, q1Y, q1Z, q1W)
		q2 := NewQuaternion(q2X, q2Y, q2Z, q2W)
		want := cQuaternionDivide(q1, q2)
		got := QuaternionDivide(q1, q2)
		if !testQuaternionEquals(want, got) {
			t.Errorf("got %v; want %v", got, want)
		}
	})
}

func BenchmarkQuaternionEquals(b *testing.B) {
	q := NewQuaternion(1, 2, 3, 4)
	p := NewQuaternion(1, 2, 3, 4)
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cQuaternionEquals(q, p)
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			QuaternionEquals(q, p)
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func FuzzQuaternionEquals(f *testing.F) {
	f.Add(
		float32(1), float32(2), float32(3), float32(4),
		float32(1), float32(2), float32(3), float32(4),
	)
	f.Fuzz(func(t *testing.T,
		qX, qY, qZ, qW float32,
		pX, pY, pZ, pW float32,
	) {
		q := NewQuaternion(qX, qY, qZ, qW)
		p := NewQuaternion(pX, pY, pZ, pW)
		want := cQuaternionEquals(q, p)
		got := QuaternionEquals(q, p)
		if want != got {
			t.Errorf("got %v; want %v", got, want)
		}
	})
}

func BenchmarkQuaternionFromAxisAngle(b *testing.B) {
	axis := NewVector3(1, 2, 3)
	angle := float32(1)
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cQuaternionFromAxisAngle(axis, angle)
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			QuaternionFromAxisAngle(axis, angle)
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func FuzzQuaternionFromAxisAngle(f *testing.F) {
	f.Add(
		float32(1), float32(2), float32(3),
		float32(1),
	)
	f.Fuzz(func(t *testing.T,
		axisX, axisY, axisZ float32,
		angle float32,
	) {
		axis := NewVector3(axisX, axisY, axisZ)
		want := cQuaternionFromAxisAngle(axis, angle)
		got := QuaternionFromAxisAngle(axis, angle)
		if !testQuaternionEquals(want, got) {
			t.Errorf("got %v; want %v", got, want)
		}
	})
}

func BenchmarkQuaternionFromEuler(b *testing.B) {
	pitch := float32(1)
	yaw := float32(2)
	roll := float32(3)
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cQuaternionFromEuler(pitch, yaw, roll)
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			QuaternionFromEuler(pitch, yaw, roll)
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func FuzzQuaternionFromEuler(f *testing.F) {
	f.Add(
		float32(1),
		float32(2),
		float32(3),
	)
	f.Fuzz(func(t *testing.T,
		pitch float32,
		yaw float32,
		roll float32,
	) {
		want := cQuaternionFromEuler(pitch, yaw, roll)
		got := QuaternionFromEuler(pitch, yaw, roll)
		if !testQuaternionEquals(want, got) {
			t.Errorf("got %v; want %v", got, want)
		}
	})
}

func BenchmarkQuaternionFromMatrix(b *testing.B) {
	mat := NewMatrix(1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4)
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cQuaternionFromMatrix(mat)
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			QuaternionFromMatrix(mat)
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func FuzzQuaternionFromMatrix(f *testing.F) {
	f.Add(
		float32(1), float32(2), float32(3), float32(4),
		float32(1), float32(2), float32(3), float32(4),
		float32(1), float32(2), float32(3), float32(4),
		float32(1), float32(2), float32(3), float32(4),
	)
	f.Fuzz(func(t *testing.T,
		matM0, matM4, matM8, matM12,
		matM1, matM5, matM9, matM13,
		matM2, matM6, matM10, matM14,
		matM3, matM7, matM11, matM15 float32,
	) {
		mat := NewMatrix(
			matM0, matM4, matM8, matM12,
			matM1, matM5, matM9, matM13,
			matM2, matM6, matM10, matM14,
			matM3, matM7, matM11, matM15,
		)
		want := cQuaternionFromMatrix(mat)
		got := QuaternionFromMatrix(mat)
		if !testQuaternionEquals(want, got) {
			t.Errorf("got %v; want %v", got, want)
		}
	})
}

func BenchmarkQuaternionFromVector3ToVector3(b *testing.B) {
	from := NewVector3(1, 2, 3)
	to := NewVector3(1, 2, 3)
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cQuaternionFromVector3ToVector3(from, to)
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			QuaternionFromVector3ToVector3(from, to)
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func FuzzQuaternionFromVector3ToVector3(f *testing.F) {
	f.Add(
		float32(1), float32(2), float32(3),
		float32(1), float32(2), float32(3),
	)
	f.Fuzz(func(t *testing.T,
		fromX, fromY, fromZ float32,
		toX, toY, toZ float32,
	) {
		from := NewVector3(fromX, fromY, fromZ)
		to := NewVector3(toX, toY, toZ)
		want := cQuaternionFromVector3ToVector3(from, to)
		got := QuaternionFromVector3ToVector3(from, to)
		if !testQuaternionEquals(want, got) {
			t.Errorf("got %v; want %v", got, want)
		}
	})
}

func BenchmarkQuaternionIdentity(b *testing.B) {
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cQuaternionIdentity()
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			QuaternionIdentity()
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func TestQuaternionIdentity(t *testing.T) {
	want := cQuaternionIdentity()
	got := QuaternionIdentity()
	if !testQuaternionEquals(want, got) {
		t.Errorf("got %v; want %v", got, want)
	}
}

func BenchmarkQuaternionInvert(b *testing.B) {
	quat := NewQuaternion(1, 2, 3, 4)
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cQuaternionInvert(quat)
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			QuaternionInvert(quat)
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func FuzzQuaternionInvert(f *testing.F) {
	f.Add(
		float32(1), float32(2), float32(3), float32(4),
	)
	f.Fuzz(func(t *testing.T,
		quatX, quatY, quatZ, quatW float32,
	) {
		quat := NewQuaternion(quatX, quatY, quatZ, quatW)
		want := cQuaternionInvert(quat)
		got := QuaternionInvert(quat)
		if !testQuaternionEquals(want, got) {
			t.Errorf("got %v; want %v", got, want)
		}
	})
}

func BenchmarkQuaternionLength(b *testing.B) {
	quat := NewQuaternion(1, 2, 3, 4)
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cQuaternionLength(quat)
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			QuaternionLength(quat)
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func FuzzQuaternionLength(f *testing.F) {
	f.Add(
		float32(1), float32(2), float32(3), float32(4),
	)
	f.Fuzz(func(t *testing.T,
		quatX, quatY, quatZ, quatW float32,
	) {
		quat := NewQuaternion(quatX, quatY, quatZ, quatW)
		want := cQuaternionLength(quat)
		got := QuaternionLength(quat)
		if !testFloat32Equals(want, got) {
			t.Errorf("got %v; want %v", got, want)
		}
	})
}

func BenchmarkQuaternionLerp(b *testing.B) {
	q1 := NewQuaternion(1, 2, 3, 4)
	q2 := NewQuaternion(1, 2, 3, 4)
	amount := float32(1)
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cQuaternionLerp(q1, q2, amount)
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			QuaternionLerp(q1, q2, amount)
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func FuzzQuaternionLerp(f *testing.F) {
	f.Add(
		float32(1), float32(2), float32(3), float32(4),
		float32(1), float32(2), float32(3), float32(4),
		float32(1),
	)
	f.Fuzz(func(t *testing.T,
		q1X, q1Y, q1Z, q1W float32,
		q2X, q2Y, q2Z, q2W float32,
		amount float32,
	) {
		q1 := NewQuaternion(q1X, q1Y, q1Z, q1W)
		q2 := NewQuaternion(q2X, q2Y, q2Z, q2W)
		want := cQuaternionLerp(q1, q2, amount)
		got := QuaternionLerp(q1, q2, amount)
		if !testQuaternionEquals(want, got) {
			t.Errorf("got %v; want %v", got, want)
		}
	})
}

func BenchmarkQuaternionMultiply(b *testing.B) {
	q1 := NewQuaternion(1, 2, 3, 4)
	q2 := NewQuaternion(1, 2, 3, 4)
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cQuaternionMultiply(q1, q2)
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			QuaternionMultiply(q1, q2)
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func FuzzQuaternionMultiply(f *testing.F) {
	f.Add(
		float32(1), float32(2), float32(3), float32(4),
		float32(1), float32(2), float32(3), float32(4),
	)
	f.Fuzz(func(t *testing.T,
		q1X, q1Y, q1Z, q1W float32,
		q2X, q2Y, q2Z, q2W float32,
	) {
		q1 := NewQuaternion(q1X, q1Y, q1Z, q1W)
		q2 := NewQuaternion(q2X, q2Y, q2Z, q2W)
		want := cQuaternionMultiply(q1, q2)
		got := QuaternionMultiply(q1, q2)
		if !testQuaternionEquals(want, got) {
			t.Errorf("got %v; want %v", got, want)
		}
	})
}

func BenchmarkQuaternionNlerp(b *testing.B) {
	q1 := NewQuaternion(1, 2, 3, 4)
	q2 := NewQuaternion(1, 2, 3, 4)
	amount := float32(1)
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cQuaternionNlerp(q1, q2, amount)
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			QuaternionNlerp(q1, q2, amount)
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func FuzzQuaternionNlerp(f *testing.F) {
	f.Add(
		float32(1), float32(2), float32(3), float32(4),
		float32(1), float32(2), float32(3), float32(4),
		float32(1),
	)
	f.Fuzz(func(t *testing.T,
		q1X, q1Y, q1Z, q1W float32,
		q2X, q2Y, q2Z, q2W float32,
		amount float32,
	) {
		q1 := NewQuaternion(q1X, q1Y, q1Z, q1W)
		q2 := NewQuaternion(q2X, q2Y, q2Z, q2W)
		want := cQuaternionNlerp(q1, q2, amount)
		got := QuaternionNlerp(q1, q2, amount)
		if !testQuaternionEquals(want, got) {
			t.Errorf("got %v; want %v", got, want)
		}
	})
}

func BenchmarkQuaternionNormalize(b *testing.B) {
	q := NewQuaternion(1, 2, 3, 4)
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cQuaternionNormalize(q)
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			QuaternionNormalize(q)
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func FuzzQuaternionNormalize(f *testing.F) {
	f.Add(
		float32(1), float32(2), float32(3), float32(4),
	)
	f.Fuzz(func(t *testing.T,
		qX, qY, qZ, qW float32,
	) {
		q := NewQuaternion(qX, qY, qZ, qW)
		want := cQuaternionNormalize(q)
		got := QuaternionNormalize(q)
		if !testQuaternionEquals(want, got) {
			t.Errorf("got %v; want %v", got, want)
		}
	})
}

func BenchmarkQuaternionScale(b *testing.B) {
	q := NewQuaternion(1, 2, 3, 4)
	mul := float32(1)
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cQuaternionScale(q, mul)
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			QuaternionScale(q, mul)
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func FuzzQuaternionScale(f *testing.F) {
	f.Add(
		float32(1), float32(2), float32(3), float32(4),
		float32(1),
	)
	f.Fuzz(func(t *testing.T,
		qX, qY, qZ, qW float32,
		mul float32,
	) {
		q := NewQuaternion(qX, qY, qZ, qW)
		want := cQuaternionScale(q, mul)
		got := QuaternionScale(q, mul)
		if !testQuaternionEquals(want, got) {
			t.Errorf("got %v; want %v", got, want)
		}
	})
}

func BenchmarkQuaternionSlerp(b *testing.B) {
	q1 := NewQuaternion(1, 2, 3, 4)
	q2 := NewQuaternion(1, 2, 3, 4)
	amount := float32(1)
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cQuaternionSlerp(q1, q2, amount)
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			QuaternionSlerp(q1, q2, amount)
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func FuzzQuaternionSlerp(f *testing.F) {
	f.Add(
		float32(1), float32(2), float32(3), float32(4),
		float32(1), float32(2), float32(3), float32(4),
		float32(1),
	)
	f.Fuzz(func(t *testing.T,
		q1X, q1Y, q1Z, q1W float32,
		q2X, q2Y, q2Z, q2W float32,
		amount float32,
	) {
		q1 := NewQuaternion(q1X, q1Y, q1Z, q1W)
		q1 = QuaternionNormalize(q1)
		q2 := NewQuaternion(q2X, q2Y, q2Z, q2W)
		q2 = QuaternionNormalize(q2)
		want := cQuaternionSlerp(q1, q2, amount)
		got := QuaternionSlerp(q1, q2, amount)
		if !testQuaternionEquals(want, got) {
			t.Errorf("got %v; want %v", got, want)
		}
	})
}

func BenchmarkQuaternionSubtract(b *testing.B) {
	q1 := NewQuaternion(1, 2, 3, 4)
	q2 := NewQuaternion(1, 2, 3, 4)
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cQuaternionSubtract(q1, q2)
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			QuaternionSubtract(q1, q2)
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func FuzzQuaternionSubtract(f *testing.F) {
	f.Add(
		float32(1), float32(2), float32(3), float32(4),
		float32(1), float32(2), float32(3), float32(4),
	)
	f.Fuzz(func(t *testing.T,
		q1X, q1Y, q1Z, q1W float32,
		q2X, q2Y, q2Z, q2W float32,
	) {
		q1 := NewQuaternion(q1X, q1Y, q1Z, q1W)
		q2 := NewQuaternion(q2X, q2Y, q2Z, q2W)
		want := cQuaternionSubtract(q1, q2)
		got := QuaternionSubtract(q1, q2)
		if !testQuaternionEquals(want, got) {
			t.Errorf("got %v; want %v", got, want)
		}
	})
}

func BenchmarkQuaternionSubtractValue(b *testing.B) {
	q := NewQuaternion(1, 2, 3, 4)
	sub := float32(1)
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cQuaternionSubtractValue(q, sub)
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			QuaternionSubtractValue(q, sub)
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func FuzzQuaternionSubtractValue(f *testing.F) {
	f.Add(
		float32(1), float32(2), float32(3), float32(4),
		float32(1),
	)
	f.Fuzz(func(t *testing.T,
		qX, qY, qZ, qW float32,
		sub float32,
	) {
		q := NewQuaternion(qX, qY, qZ, qW)
		want := cQuaternionSubtractValue(q, sub)
		got := QuaternionSubtractValue(q, sub)
		if !testQuaternionEquals(want, got) {
			t.Errorf("got %v; want %v", got, want)
		}
	})
}

func BenchmarkQuaternionToEuler(b *testing.B) {
	q := NewQuaternion(1, 2, 3, 4)
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cQuaternionToEuler(q)
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			QuaternionToEuler(q)
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func FuzzQuaternionToEuler(f *testing.F) {
	f.Add(
		float32(1), float32(2), float32(3), float32(4),
	)
	f.Fuzz(func(t *testing.T,
		qX, qY, qZ, qW float32,
	) {
		q := NewQuaternion(qX, qY, qZ, qW)
		want := cQuaternionToEuler(q)
		got := QuaternionToEuler(q)
		if !testVector3Equals(want, got) {
			t.Errorf("got %v; want %v", got, want)
		}
	})
}

func BenchmarkQuaternionToMatrix(b *testing.B) {
	q := NewQuaternion(1, 2, 3, 4)
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cQuaternionToMatrix(q)
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			QuaternionToMatrix(q)
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func FuzzQuaternionToMatrix(f *testing.F) {
	f.Add(
		float32(1), float32(2), float32(3), float32(4),
	)
	f.Fuzz(func(t *testing.T,
		qX, qY, qZ, qW float32,
	) {
		q := NewQuaternion(qX, qY, qZ, qW)
		want := cQuaternionToMatrix(q)
		got := QuaternionToMatrix(q)
		if !testMatrixEquals(want, got) {
			t.Errorf("got %v; want %v", got, want)
		}
	})
}

func BenchmarkQuaternionTransform(b *testing.B) {
	q := NewQuaternion(1, 2, 3, 4)
	mat := NewMatrix(1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4)
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cQuaternionTransform(q, mat)
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			QuaternionTransform(q, mat)
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func FuzzQuaternionTransform(f *testing.F) {
	f.Add(
		float32(1), float32(2), float32(3), float32(4),
		float32(1), float32(2), float32(3), float32(4),
		float32(1), float32(2), float32(3), float32(4),
		float32(1), float32(2), float32(3), float32(4),
		float32(1), float32(2), float32(3), float32(4),
	)
	f.Fuzz(func(t *testing.T,
		qX, qY, qZ, qW float32,
		matM0, matM4, matM8, matM12,
		matM1, matM5, matM9, matM13,
		matM2, matM6, matM10, matM14,
		matM3, matM7, matM11, matM15 float32,
	) {
		q := NewQuaternion(qX, qY, qZ, qW)
		mat := NewMatrix(
			matM0, matM4, matM8, matM12,
			matM1, matM5, matM9, matM13,
			matM2, matM6, matM10, matM14,
			matM3, matM7, matM11, matM15,
		)
		want := cQuaternionTransform(q, mat)
		got := QuaternionTransform(q, mat)
		if !testQuaternionEquals(want, got) {
			t.Errorf("got %v; want %v", got, want)
		}
	})
}

func BenchmarkRemap(b *testing.B) {
	value := float32(1)
	inputStart := float32(2)
	inputEnd := float32(3)
	outputStart := float32(4)
	outputEnd := float32(5)
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cRemap(value, inputStart, inputEnd, outputStart, outputEnd)
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			Remap(value, inputStart, inputEnd, outputStart, outputEnd)
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func FuzzRemap(f *testing.F) {
	f.Add(
		float32(1),
		float32(2),
		float32(3),
		float32(4),
		float32(5),
	)
	f.Fuzz(func(t *testing.T,
		value float32,
		inputStart float32,
		inputEnd float32,
		outputStart float32,
		outputEnd float32,
	) {
		want := cRemap(value, inputStart, inputEnd, outputStart, outputEnd)
		got := Remap(value, inputStart, inputEnd, outputStart, outputEnd)
		if !testFloat32Equals(want, got) {
			t.Errorf("got %v; want %v", got, want)
		}
	})
}

func BenchmarkVector2Add(b *testing.B) {
	v1 := NewVector2(1, 2)
	v2 := NewVector2(1, 2)
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cVector2Add(v1, v2)
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			Vector2Add(v1, v2)
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func FuzzVector2Add(f *testing.F) {
	f.Add(
		float32(1), float32(2),
		float32(1), float32(2),
	)
	f.Fuzz(func(t *testing.T,
		v1X, v1Y float32,
		v2X, v2Y float32,
	) {
		v1 := NewVector2(v1X, v1Y)
		v2 := NewVector2(v2X, v2Y)
		want := cVector2Add(v1, v2)
		got := Vector2Add(v1, v2)
		if !testVector2Equals(want, got) {
			t.Errorf("got %v; want %v", got, want)
		}
	})
}

func BenchmarkVector2AddValue(b *testing.B) {
	v := NewVector2(1, 2)
	add := float32(1)
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cVector2AddValue(v, add)
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			Vector2AddValue(v, add)
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func FuzzVector2AddValue(f *testing.F) {
	f.Add(
		float32(1), float32(2),
		float32(1),
	)
	f.Fuzz(func(t *testing.T,
		vX, vY float32,
		add float32,
	) {
		v := NewVector2(vX, vY)
		want := cVector2AddValue(v, add)
		got := Vector2AddValue(v, add)
		if !testVector2Equals(want, got) {
			t.Errorf("got %v; want %v", got, want)
		}
	})
}

func BenchmarkVector2Angle(b *testing.B) {
	v1 := NewVector2(1, 2)
	v2 := NewVector2(1, 2)
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cVector2Angle(v1, v2)
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			Vector2Angle(v1, v2)
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func FuzzVector2Angle(f *testing.F) {
	f.Add(
		float32(1), float32(2),
		float32(1), float32(2),
	)
	f.Fuzz(func(t *testing.T,
		v1X, v1Y float32,
		v2X, v2Y float32,
	) {
		v1 := NewVector2(v1X, v1Y)
		v2 := NewVector2(v2X, v2Y)
		want := cVector2Angle(v1, v2)
		got := Vector2Angle(v1, v2)
		if !testFloat32Equals(want, got) {
			t.Errorf("got %v; want %v", got, want)
		}
	})
}

func BenchmarkVector2Clamp(b *testing.B) {
	v := NewVector2(1, 2)
	min := NewVector2(1, 2)
	max := NewVector2(1, 2)
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cVector2Clamp(v, min, max)
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			Vector2Clamp(v, min, max)
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func FuzzVector2Clamp(f *testing.F) {
	f.Add(
		float32(1), float32(2),
		float32(1), float32(2),
		float32(1), float32(2),
	)
	f.Fuzz(func(t *testing.T,
		vX, vY float32,
		minX, minY float32,
		maxX, maxY float32,
	) {
		v := NewVector2(vX, vY)
		min := NewVector2(minX, minY)
		max := NewVector2(maxX, maxY)
		want := cVector2Clamp(v, min, max)
		got := Vector2Clamp(v, min, max)
		if !testVector2Equals(want, got) {
			t.Errorf("got %v; want %v", got, want)
		}
	})
}

func BenchmarkVector2ClampValue(b *testing.B) {
	v := NewVector2(1, 2)
	min := float32(1)
	max := float32(1)
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cVector2ClampValue(v, min, max)
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			Vector2ClampValue(v, min, max)
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func FuzzVector2ClampValue(f *testing.F) {
	f.Add(
		float32(1), float32(2),
		float32(1),
		float32(1),
	)
	f.Fuzz(func(t *testing.T,
		vX, vY float32,
		min float32,
		max float32,
	) {
		v := NewVector2(vX, vY)
		want := cVector2ClampValue(v, min, max)
		got := Vector2ClampValue(v, min, max)
		if !testVector2Equals(want, got) {
			t.Errorf("got %v; want %v", got, want)
		}
	})
}

func BenchmarkVector2CrossProduct(b *testing.B) {
	v1 := NewVector2(1, 2)
	v2 := NewVector2(1, 2)
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cVector2CrossProduct(v1, v2)
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			Vector2CrossProduct(v1, v2)
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func FuzzVector2CrossProduct(f *testing.F) {
	f.Add(
		float32(1), float32(2),
		float32(1), float32(2),
	)
	f.Fuzz(func(t *testing.T,
		v1X, v1Y float32,
		v2X, v2Y float32,
	) {
		v1 := NewVector2(v1X, v1Y)
		v2 := NewVector2(v2X, v2Y)
		want := cVector2CrossProduct(v1, v2)
		got := Vector2CrossProduct(v1, v2)
		if !testFloat32Equals(want, got) {
			t.Errorf("got %v; want %v", got, want)
		}
	})
}

func BenchmarkVector2Distance(b *testing.B) {
	v1 := NewVector2(1, 2)
	v2 := NewVector2(1, 2)
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cVector2Distance(v1, v2)
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			Vector2Distance(v1, v2)
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func FuzzVector2Distance(f *testing.F) {
	f.Add(
		float32(1), float32(2),
		float32(1), float32(2),
	)
	f.Fuzz(func(t *testing.T,
		v1X, v1Y float32,
		v2X, v2Y float32,
	) {
		v1 := NewVector2(v1X, v1Y)
		v2 := NewVector2(v2X, v2Y)
		want := cVector2Distance(v1, v2)
		got := Vector2Distance(v1, v2)
		if !testFloat32Equals(want, got) {
			t.Errorf("got %v; want %v", got, want)
		}
	})
}

func BenchmarkVector2DistanceSqr(b *testing.B) {
	v1 := NewVector2(1, 2)
	v2 := NewVector2(1, 2)
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cVector2DistanceSqr(v1, v2)
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			Vector2DistanceSqr(v1, v2)
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func FuzzVector2DistanceSqr(f *testing.F) {
	f.Add(
		float32(1), float32(2),
		float32(1), float32(2),
	)
	f.Fuzz(func(t *testing.T,
		v1X, v1Y float32,
		v2X, v2Y float32,
	) {
		v1 := NewVector2(v1X, v1Y)
		v2 := NewVector2(v2X, v2Y)
		want := cVector2DistanceSqr(v1, v2)
		got := Vector2DistanceSqr(v1, v2)
		if !testFloat32Equals(want, got) {
			t.Errorf("got %v; want %v", got, want)
		}
	})
}

func BenchmarkVector2Divide(b *testing.B) {
	v1 := NewVector2(1, 2)
	v2 := NewVector2(1, 2)
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cVector2Divide(v1, v2)
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			Vector2Divide(v1, v2)
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func FuzzVector2Divide(f *testing.F) {
	f.Add(
		float32(1), float32(2),
		float32(1), float32(2),
	)
	f.Fuzz(func(t *testing.T,
		v1X, v1Y float32,
		v2X, v2Y float32,
	) {
		v1 := NewVector2(v1X, v1Y)
		v2 := NewVector2(v2X, v2Y)
		want := cVector2Divide(v1, v2)
		got := Vector2Divide(v1, v2)
		if !testVector2Equals(want, got) {
			t.Errorf("got %v; want %v", got, want)
		}
	})
}

func BenchmarkVector2DotProduct(b *testing.B) {
	v1 := NewVector2(1, 2)
	v2 := NewVector2(1, 2)
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cVector2DotProduct(v1, v2)
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			Vector2DotProduct(v1, v2)
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func FuzzVector2DotProduct(f *testing.F) {
	f.Add(
		float32(1), float32(2),
		float32(1), float32(2),
	)
	f.Fuzz(func(t *testing.T,
		v1X, v1Y float32,
		v2X, v2Y float32,
	) {
		v1 := NewVector2(v1X, v1Y)
		v2 := NewVector2(v2X, v2Y)
		want := cVector2DotProduct(v1, v2)
		got := Vector2DotProduct(v1, v2)
		if !testFloat32Equals(want, got) {
			t.Errorf("got %v; want %v", got, want)
		}
	})
}

func BenchmarkVector2Equals(b *testing.B) {
	p := NewVector2(1, 2)
	q := NewVector2(1, 2)
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cVector2Equals(p, q)
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			Vector2Equals(p, q)
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func FuzzVector2Equals(f *testing.F) {
	f.Add(
		float32(1), float32(2),
		float32(1), float32(2),
	)
	f.Fuzz(func(t *testing.T,
		pX, pY float32,
		qX, qY float32,
	) {
		p := NewVector2(pX, pY)
		q := NewVector2(qX, qY)
		want := cVector2Equals(p, q)
		got := Vector2Equals(p, q)
		if want != got {
			t.Errorf("got %v; want %v", got, want)
		}
	})
}

func BenchmarkVector2Invert(b *testing.B) {
	v := NewVector2(1, 2)
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cVector2Invert(v)
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			Vector2Invert(v)
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func FuzzVector2Invert(f *testing.F) {
	f.Add(
		float32(1), float32(2),
	)
	f.Fuzz(func(t *testing.T,
		vX, vY float32,
	) {
		v := NewVector2(vX, vY)
		want := cVector2Invert(v)
		got := Vector2Invert(v)
		if !testVector2Equals(want, got) {
			t.Errorf("got %v; want %v", got, want)
		}
	})
}

func BenchmarkVector2Length(b *testing.B) {
	v := NewVector2(1, 2)
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cVector2Length(v)
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			Vector2Length(v)
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func FuzzVector2Length(f *testing.F) {
	f.Add(
		float32(1), float32(2),
	)
	f.Fuzz(func(t *testing.T,
		vX, vY float32,
	) {
		v := NewVector2(vX, vY)
		want := cVector2Length(v)
		got := Vector2Length(v)
		if !testFloat32Equals(want, got) {
			t.Errorf("got %v; want %v", got, want)
		}
	})
}

func BenchmarkVector2LengthSqr(b *testing.B) {
	v := NewVector2(1, 2)
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cVector2LengthSqr(v)
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			Vector2LengthSqr(v)
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func FuzzVector2LengthSqr(f *testing.F) {
	f.Add(
		float32(1), float32(2),
	)
	f.Fuzz(func(t *testing.T,
		vX, vY float32,
	) {
		v := NewVector2(vX, vY)
		want := cVector2LengthSqr(v)
		got := Vector2LengthSqr(v)
		if !testFloat32Equals(want, got) {
			t.Errorf("got %v; want %v", got, want)
		}
	})
}

func BenchmarkVector2Lerp(b *testing.B) {
	v1 := NewVector2(1, 2)
	v2 := NewVector2(1, 2)
	amount := float32(1)
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cVector2Lerp(v1, v2, amount)
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			Vector2Lerp(v1, v2, amount)
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func FuzzVector2Lerp(f *testing.F) {
	f.Add(
		float32(1), float32(2),
		float32(1), float32(2),
		float32(1),
	)
	f.Fuzz(func(t *testing.T,
		v1X, v1Y float32,
		v2X, v2Y float32,
		amount float32,
	) {
		v1 := NewVector2(v1X, v1Y)
		v2 := NewVector2(v2X, v2Y)
		want := cVector2Lerp(v1, v2, amount)
		got := Vector2Lerp(v1, v2, amount)
		if !testVector2Equals(want, got) {
			t.Errorf("got %v; want %v", got, want)
		}
	})
}

func BenchmarkVector2LineAngle(b *testing.B) {
	start := NewVector2(1, 2)
	end := NewVector2(1, 2)
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cVector2LineAngle(start, end)
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			Vector2LineAngle(start, end)
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func FuzzVector2LineAngle(f *testing.F) {
	f.Add(
		float32(1), float32(2),
		float32(1), float32(2),
	)
	f.Fuzz(func(t *testing.T,
		startX, startY float32,
		endX, endY float32,
	) {
		start := NewVector2(startX, startY)
		end := NewVector2(endX, endY)
		want := cVector2LineAngle(start, end)
		got := Vector2LineAngle(start, end)
		if !testFloat32Equals(want, got) {
			t.Errorf("got %v; want %v", got, want)
		}
	})
}

func BenchmarkVector2MoveTowards(b *testing.B) {
	v := NewVector2(1, 2)
	target := NewVector2(1, 2)
	maxDistance := float32(1)
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cVector2MoveTowards(v, target, maxDistance)
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			Vector2MoveTowards(v, target, maxDistance)
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func FuzzVector2MoveTowards(f *testing.F) {
	f.Add(
		float32(1), float32(2),
		float32(1), float32(2),
		float32(1),
	)
	f.Fuzz(func(t *testing.T,
		vX, vY float32,
		targetX, targetY float32,
		maxDistance float32,
	) {
		v := NewVector2(vX, vY)
		target := NewVector2(targetX, targetY)
		want := cVector2MoveTowards(v, target, maxDistance)
		got := Vector2MoveTowards(v, target, maxDistance)
		if !testVector2Equals(want, got) {
			t.Errorf("got %v; want %v", got, want)
		}
	})
}

func BenchmarkVector2Multiply(b *testing.B) {
	v1 := NewVector2(1, 2)
	v2 := NewVector2(1, 2)
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cVector2Multiply(v1, v2)
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			Vector2Multiply(v1, v2)
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func FuzzVector2Multiply(f *testing.F) {
	f.Add(
		float32(1), float32(2),
		float32(1), float32(2),
	)
	f.Fuzz(func(t *testing.T,
		v1X, v1Y float32,
		v2X, v2Y float32,
	) {
		v1 := NewVector2(v1X, v1Y)
		v2 := NewVector2(v2X, v2Y)
		want := cVector2Multiply(v1, v2)
		got := Vector2Multiply(v1, v2)
		if !testVector2Equals(want, got) {
			t.Errorf("got %v; want %v", got, want)
		}
	})
}

func BenchmarkVector2Negate(b *testing.B) {
	v := NewVector2(1, 2)
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cVector2Negate(v)
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			Vector2Negate(v)
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func FuzzVector2Negate(f *testing.F) {
	f.Add(
		float32(1), float32(2),
	)
	f.Fuzz(func(t *testing.T,
		vX, vY float32,
	) {
		v := NewVector2(vX, vY)
		want := cVector2Negate(v)
		got := Vector2Negate(v)
		if !testVector2Equals(want, got) {
			t.Errorf("got %v; want %v", got, want)
		}
	})
}

func BenchmarkVector2Normalize(b *testing.B) {
	v := NewVector2(1, 2)
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cVector2Normalize(v)
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			Vector2Normalize(v)
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func FuzzVector2Normalize(f *testing.F) {
	f.Add(
		float32(1), float32(2),
	)
	f.Fuzz(func(t *testing.T,
		vX, vY float32,
	) {
		v := NewVector2(vX, vY)
		want := cVector2Normalize(v)
		got := Vector2Normalize(v)
		if !testVector2Equals(want, got) {
			t.Errorf("got %v; want %v", got, want)
		}
	})
}

func BenchmarkVector2One(b *testing.B) {
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cVector2One()
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			Vector2One()
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func TestVector2One(t *testing.T) {
	want := cVector2One()
	got := Vector2One()
	if !testVector2Equals(want, got) {
		t.Errorf("got %v; want %v", got, want)
	}
}

func BenchmarkVector2Reflect(b *testing.B) {
	v := NewVector2(1, 2)
	normal := NewVector2(1, 2)
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cVector2Reflect(v, normal)
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			Vector2Reflect(v, normal)
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func FuzzVector2Reflect(f *testing.F) {
	f.Add(
		float32(1), float32(2),
		float32(1), float32(2),
	)
	f.Fuzz(func(t *testing.T,
		vX, vY float32,
		normalX, normalY float32,
	) {
		v := NewVector2(vX, vY)
		normal := NewVector2(normalX, normalY)
		want := cVector2Reflect(v, normal)
		got := Vector2Reflect(v, normal)
		if !testVector2Equals(want, got) {
			t.Errorf("got %v; want %v", got, want)
		}
	})
}

func BenchmarkVector2Rotate(b *testing.B) {
	v := NewVector2(1, 2)
	angle := float32(1)
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cVector2Rotate(v, angle)
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			Vector2Rotate(v, angle)
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func FuzzVector2Rotate(f *testing.F) {
	f.Add(
		float32(1), float32(2),
		float32(1),
	)
	f.Fuzz(func(t *testing.T,
		vX, vY float32,
		angle float32,
	) {
		v := NewVector2(vX, vY)
		v = Vector2Normalize(v)
		want := cVector2Rotate(v, angle)
		got := Vector2Rotate(v, angle)
		if !testVector2Equals(want, got) {
			t.Errorf("got %v; want %v", got, want)
		}
	})
}

func BenchmarkVector2Scale(b *testing.B) {
	v := NewVector2(1, 2)
	scale := float32(1)
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cVector2Scale(v, scale)
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			Vector2Scale(v, scale)
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func FuzzVector2Scale(f *testing.F) {
	f.Add(
		float32(1), float32(2),
		float32(1),
	)
	f.Fuzz(func(t *testing.T,
		vX, vY float32,
		scale float32,
	) {
		v := NewVector2(vX, vY)
		want := cVector2Scale(v, scale)
		got := Vector2Scale(v, scale)
		if !testVector2Equals(want, got) {
			t.Errorf("got %v; want %v", got, want)
		}
	})
}

func BenchmarkVector2Subtract(b *testing.B) {
	v1 := NewVector2(1, 2)
	v2 := NewVector2(1, 2)
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cVector2Subtract(v1, v2)
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			Vector2Subtract(v1, v2)
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func FuzzVector2Subtract(f *testing.F) {
	f.Add(
		float32(1), float32(2),
		float32(1), float32(2),
	)
	f.Fuzz(func(t *testing.T,
		v1X, v1Y float32,
		v2X, v2Y float32,
	) {
		v1 := NewVector2(v1X, v1Y)
		v2 := NewVector2(v2X, v2Y)
		want := cVector2Subtract(v1, v2)
		got := Vector2Subtract(v1, v2)
		if !testVector2Equals(want, got) {
			t.Errorf("got %v; want %v", got, want)
		}
	})
}

func BenchmarkVector2SubtractValue(b *testing.B) {
	v := NewVector2(1, 2)
	sub := float32(1)
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cVector2SubtractValue(v, sub)
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			Vector2SubtractValue(v, sub)
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func FuzzVector2SubtractValue(f *testing.F) {
	f.Add(
		float32(1), float32(2),
		float32(1),
	)
	f.Fuzz(func(t *testing.T,
		vX, vY float32,
		sub float32,
	) {
		v := NewVector2(vX, vY)
		want := cVector2SubtractValue(v, sub)
		got := Vector2SubtractValue(v, sub)
		if !testVector2Equals(want, got) {
			t.Errorf("got %v; want %v", got, want)
		}
	})
}

func BenchmarkVector2Transform(b *testing.B) {
	v := NewVector2(1, 2)
	mat := NewMatrix(1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4)
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cVector2Transform(v, mat)
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			Vector2Transform(v, mat)
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func FuzzVector2Transform(f *testing.F) {
	f.Add(
		float32(1), float32(2),
		float32(1), float32(2), float32(3), float32(4),
		float32(1), float32(2), float32(3), float32(4),
		float32(1), float32(2), float32(3), float32(4),
		float32(1), float32(2), float32(3), float32(4),
	)
	f.Fuzz(func(t *testing.T,
		vX, vY float32,
		matM0, matM4, matM8, matM12,
		matM1, matM5, matM9, matM13,
		matM2, matM6, matM10, matM14,
		matM3, matM7, matM11, matM15 float32,
	) {
		v := NewVector2(vX, vY)
		mat := NewMatrix(
			matM0, matM4, matM8, matM12,
			matM1, matM5, matM9, matM13,
			matM2, matM6, matM10, matM14,
			matM3, matM7, matM11, matM15,
		)
		want := cVector2Transform(v, mat)
		got := Vector2Transform(v, mat)
		if !testVector2Equals(want, got) {
			t.Errorf("got %v; want %v", got, want)
		}
	})
}

func BenchmarkVector2Zero(b *testing.B) {
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cVector2Zero()
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			Vector2Zero()
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func TestVector2Zero(t *testing.T) {
	want := cVector2Zero()
	got := Vector2Zero()
	if !testVector2Equals(want, got) {
		t.Errorf("got %v; want %v", got, want)
	}
}

func BenchmarkVector3Add(b *testing.B) {
	v1 := NewVector3(1, 2, 3)
	v2 := NewVector3(1, 2, 3)
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cVector3Add(v1, v2)
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			Vector3Add(v1, v2)
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func FuzzVector3Add(f *testing.F) {
	f.Add(
		float32(1), float32(2), float32(3),
		float32(1), float32(2), float32(3),
	)
	f.Fuzz(func(t *testing.T,
		v1X, v1Y, v1Z float32,
		v2X, v2Y, v2Z float32,
	) {
		v1 := NewVector3(v1X, v1Y, v1Z)
		v2 := NewVector3(v2X, v2Y, v2Z)
		want := cVector3Add(v1, v2)
		got := Vector3Add(v1, v2)
		if !testVector3Equals(want, got) {
			t.Errorf("got %v; want %v", got, want)
		}
	})
}

func BenchmarkVector3AddValue(b *testing.B) {
	v := NewVector3(1, 2, 3)
	add := float32(1)
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cVector3AddValue(v, add)
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			Vector3AddValue(v, add)
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func FuzzVector3AddValue(f *testing.F) {
	f.Add(
		float32(1), float32(2), float32(3),
		float32(1),
	)
	f.Fuzz(func(t *testing.T,
		vX, vY, vZ float32,
		add float32,
	) {
		v := NewVector3(vX, vY, vZ)
		want := cVector3AddValue(v, add)
		got := Vector3AddValue(v, add)
		if !testVector3Equals(want, got) {
			t.Errorf("got %v; want %v", got, want)
		}
	})
}

func BenchmarkVector3Angle(b *testing.B) {
	v1 := NewVector3(1, 2, 3)
	v2 := NewVector3(1, 2, 3)
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cVector3Angle(v1, v2)
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			Vector3Angle(v1, v2)
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func FuzzVector3Angle(f *testing.F) {
	f.Add(
		float32(1), float32(2), float32(3),
		float32(1), float32(2), float32(3),
	)
	f.Fuzz(func(t *testing.T,
		v1X, v1Y, v1Z float32,
		v2X, v2Y, v2Z float32,
	) {
		v1 := NewVector3(v1X, v1Y, v1Z)
		v2 := NewVector3(v2X, v2Y, v2Z)
		want := cVector3Angle(v1, v2)
		got := Vector3Angle(v1, v2)
		if !testFloat32Equals(want, got) {
			t.Errorf("got %v; want %v", got, want)
		}
	})
}

func BenchmarkVector3Barycenter(b *testing.B) {
	p := NewVector3(1, 2, 3)
	a := NewVector3(1, 2, 3)
	b1 := NewVector3(1, 2, 3)
	c := NewVector3(1, 2, 3)
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cVector3Barycenter(p, a, b1, c)
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			Vector3Barycenter(p, a, b1, c)
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func FuzzVector3Barycenter(f *testing.F) {
	f.Add(
		float32(1), float32(2), float32(3),
		float32(1), float32(2), float32(3),
		float32(1), float32(2), float32(3),
		float32(1), float32(2), float32(3),
	)
	f.Fuzz(func(t *testing.T,
		pX, pY, pZ float32,
		aX, aY, aZ float32,
		bX, bY, bZ float32,
		cX, cY, cZ float32,
	) {
		p := NewVector3(pX, pY, pZ)
		a := NewVector3(aX, aY, aZ)
		b1 := NewVector3(bX, bY, bZ)
		c := NewVector3(cX, cY, cZ)
		want := cVector3Barycenter(p, a, b1, c)
		got := Vector3Barycenter(p, a, b1, c)
		if !testVector3Equals(want, got) {
			t.Errorf("got %v; want %v", got, want)
		}
	})
}

func BenchmarkVector3Clamp(b *testing.B) {
	v := NewVector3(1, 2, 3)
	min := NewVector3(1, 2, 3)
	max := NewVector3(1, 2, 3)
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cVector3Clamp(v, min, max)
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			Vector3Clamp(v, min, max)
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func FuzzVector3Clamp(f *testing.F) {
	f.Add(
		float32(1), float32(2), float32(3),
		float32(1), float32(2), float32(3),
		float32(1), float32(2), float32(3),
	)
	f.Fuzz(func(t *testing.T,
		vX, vY, vZ float32,
		minX, minY, minZ float32,
		maxX, maxY, maxZ float32,
	) {
		v := NewVector3(vX, vY, vZ)
		min := NewVector3(minX, minY, minZ)
		max := NewVector3(maxX, maxY, maxZ)
		want := cVector3Clamp(v, min, max)
		got := Vector3Clamp(v, min, max)
		if !testVector3Equals(want, got) {
			t.Errorf("got %v; want %v", got, want)
		}
	})
}

func BenchmarkVector3ClampValue(b *testing.B) {
	v := NewVector3(1, 2, 3)
	min := float32(1)
	max := float32(1)
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cVector3ClampValue(v, min, max)
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			Vector3ClampValue(v, min, max)
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func FuzzVector3ClampValue(f *testing.F) {
	f.Add(
		float32(1), float32(2), float32(3),
		float32(1),
		float32(1),
	)
	f.Fuzz(func(t *testing.T,
		vX, vY, vZ float32,
		min float32,
		max float32,
	) {
		v := NewVector3(vX, vY, vZ)
		want := cVector3ClampValue(v, min, max)
		got := Vector3ClampValue(v, min, max)
		if !testVector3Equals(want, got) {
			t.Errorf("got %v; want %v", got, want)
		}
	})
}

func BenchmarkVector3CrossProduct(b *testing.B) {
	v1 := NewVector3(1, 2, 3)
	v2 := NewVector3(1, 2, 3)
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cVector3CrossProduct(v1, v2)
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			Vector3CrossProduct(v1, v2)
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func FuzzVector3CrossProduct(f *testing.F) {
	f.Add(
		float32(1), float32(2), float32(3),
		float32(1), float32(2), float32(3),
	)
	f.Fuzz(func(t *testing.T,
		v1X, v1Y, v1Z float32,
		v2X, v2Y, v2Z float32,
	) {
		v1 := NewVector3(v1X, v1Y, v1Z)
		v2 := NewVector3(v2X, v2Y, v2Z)
		want := cVector3CrossProduct(v1, v2)
		got := Vector3CrossProduct(v1, v2)
		if !testVector3Equals(want, got) {
			t.Errorf("got %v; want %v", got, want)
		}
	})
}

func BenchmarkVector3Distance(b *testing.B) {
	v1 := NewVector3(1, 2, 3)
	v2 := NewVector3(1, 2, 3)
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cVector3Distance(v1, v2)
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			Vector3Distance(v1, v2)
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func FuzzVector3Distance(f *testing.F) {
	f.Add(
		float32(1), float32(2), float32(3),
		float32(1), float32(2), float32(3),
	)
	f.Fuzz(func(t *testing.T,
		v1X, v1Y, v1Z float32,
		v2X, v2Y, v2Z float32,
	) {
		v1 := NewVector3(v1X, v1Y, v1Z)
		v2 := NewVector3(v2X, v2Y, v2Z)
		want := cVector3Distance(v1, v2)
		got := Vector3Distance(v1, v2)
		if !testFloat32Equals(want, got) {
			t.Errorf("got %v; want %v", got, want)
		}
	})
}

func BenchmarkVector3DistanceSqr(b *testing.B) {
	v1 := NewVector3(1, 2, 3)
	v2 := NewVector3(1, 2, 3)
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cVector3DistanceSqr(v1, v2)
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			Vector3DistanceSqr(v1, v2)
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func FuzzVector3DistanceSqr(f *testing.F) {
	f.Add(
		float32(1), float32(2), float32(3),
		float32(1), float32(2), float32(3),
	)
	f.Fuzz(func(t *testing.T,
		v1X, v1Y, v1Z float32,
		v2X, v2Y, v2Z float32,
	) {
		v1 := NewVector3(v1X, v1Y, v1Z)
		v2 := NewVector3(v2X, v2Y, v2Z)
		want := cVector3DistanceSqr(v1, v2)
		got := Vector3DistanceSqr(v1, v2)
		if !testFloat32Equals(want, got) {
			t.Errorf("got %v; want %v", got, want)
		}
	})
}

func BenchmarkVector3Divide(b *testing.B) {
	v1 := NewVector3(1, 2, 3)
	v2 := NewVector3(1, 2, 3)
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cVector3Divide(v1, v2)
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			Vector3Divide(v1, v2)
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func FuzzVector3Divide(f *testing.F) {
	f.Add(
		float32(1), float32(2), float32(3),
		float32(1), float32(2), float32(3),
	)
	f.Fuzz(func(t *testing.T,
		v1X, v1Y, v1Z float32,
		v2X, v2Y, v2Z float32,
	) {
		v1 := NewVector3(v1X, v1Y, v1Z)
		v2 := NewVector3(v2X, v2Y, v2Z)
		want := cVector3Divide(v1, v2)
		got := Vector3Divide(v1, v2)
		if !testVector3Equals(want, got) {
			t.Errorf("got %v; want %v", got, want)
		}
	})
}

func BenchmarkVector3DotProduct(b *testing.B) {
	v1 := NewVector3(1, 2, 3)
	v2 := NewVector3(1, 2, 3)
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cVector3DotProduct(v1, v2)
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			Vector3DotProduct(v1, v2)
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func FuzzVector3DotProduct(f *testing.F) {
	f.Add(
		float32(1), float32(2), float32(3),
		float32(1), float32(2), float32(3),
	)
	f.Fuzz(func(t *testing.T,
		v1X, v1Y, v1Z float32,
		v2X, v2Y, v2Z float32,
	) {
		v1 := NewVector3(v1X, v1Y, v1Z)
		v2 := NewVector3(v2X, v2Y, v2Z)
		want := cVector3DotProduct(v1, v2)
		got := Vector3DotProduct(v1, v2)
		if !testFloat32Equals(want, got) {
			t.Errorf("got %v; want %v", got, want)
		}
	})
}

func BenchmarkVector3Equals(b *testing.B) {
	p := NewVector3(1, 2, 3)
	q := NewVector3(1, 2, 3)
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cVector3Equals(p, q)
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			Vector3Equals(p, q)
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func FuzzVector3Equals(f *testing.F) {
	f.Add(
		float32(1), float32(2), float32(3),
		float32(1), float32(2), float32(3),
	)
	f.Fuzz(func(t *testing.T,
		pX, pY, pZ float32,
		qX, qY, qZ float32,
	) {
		p := NewVector3(pX, pY, pZ)
		q := NewVector3(qX, qY, qZ)
		want := cVector3Equals(p, q)
		got := Vector3Equals(p, q)
		if want != got {
			t.Errorf("got %v; want %v", got, want)
		}
	})
}

func BenchmarkVector3Invert(b *testing.B) {
	v := NewVector3(1, 2, 3)
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cVector3Invert(v)
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			Vector3Invert(v)
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func FuzzVector3Invert(f *testing.F) {
	f.Add(
		float32(1), float32(2), float32(3),
	)
	f.Fuzz(func(t *testing.T,
		vX, vY, vZ float32,
	) {
		v := NewVector3(vX, vY, vZ)
		want := cVector3Invert(v)
		got := Vector3Invert(v)
		if !testVector3Equals(want, got) {
			t.Errorf("got %v; want %v", got, want)
		}
	})
}

func BenchmarkVector3Length(b *testing.B) {
	v := NewVector3(1, 2, 3)
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cVector3Length(v)
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			Vector3Length(v)
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func FuzzVector3Length(f *testing.F) {
	f.Add(
		float32(1), float32(2), float32(3),
	)
	f.Fuzz(func(t *testing.T,
		vX, vY, vZ float32,
	) {
		v := NewVector3(vX, vY, vZ)
		want := cVector3Length(v)
		got := Vector3Length(v)
		if !testFloat32Equals(want, got) {
			t.Errorf("got %v; want %v", got, want)
		}
	})
}

func BenchmarkVector3LengthSqr(b *testing.B) {
	v := NewVector3(1, 2, 3)
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cVector3LengthSqr(v)
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			Vector3LengthSqr(v)
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func FuzzVector3LengthSqr(f *testing.F) {
	f.Add(
		float32(1), float32(2), float32(3),
	)
	f.Fuzz(func(t *testing.T,
		vX, vY, vZ float32,
	) {
		v := NewVector3(vX, vY, vZ)
		want := cVector3LengthSqr(v)
		got := Vector3LengthSqr(v)
		if !testFloat32Equals(want, got) {
			t.Errorf("got %v; want %v", got, want)
		}
	})
}

func BenchmarkVector3Lerp(b *testing.B) {
	v1 := NewVector3(1, 2, 3)
	v2 := NewVector3(1, 2, 3)
	amount := float32(1)
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cVector3Lerp(v1, v2, amount)
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			Vector3Lerp(v1, v2, amount)
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func FuzzVector3Lerp(f *testing.F) {
	f.Add(
		float32(1), float32(2), float32(3),
		float32(1), float32(2), float32(3),
		float32(1),
	)
	f.Fuzz(func(t *testing.T,
		v1X, v1Y, v1Z float32,
		v2X, v2Y, v2Z float32,
		amount float32,
	) {
		v1 := NewVector3(v1X, v1Y, v1Z)
		v2 := NewVector3(v2X, v2Y, v2Z)
		want := cVector3Lerp(v1, v2, amount)
		got := Vector3Lerp(v1, v2, amount)
		if !testVector3Equals(want, got) {
			t.Errorf("got %v; want %v", got, want)
		}
	})
}

func BenchmarkVector3Max(b *testing.B) {
	vec1 := NewVector3(1, 2, 3)
	vec2 := NewVector3(1, 2, 3)
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cVector3Max(vec1, vec2)
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			Vector3Max(vec1, vec2)
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func FuzzVector3Max(f *testing.F) {
	f.Add(
		float32(1), float32(2), float32(3),
		float32(1), float32(2), float32(3),
	)
	f.Fuzz(func(t *testing.T,
		vec1X, vec1Y, vec1Z float32,
		vec2X, vec2Y, vec2Z float32,
	) {
		vec1 := NewVector3(vec1X, vec1Y, vec1Z)
		vec2 := NewVector3(vec2X, vec2Y, vec2Z)
		want := cVector3Max(vec1, vec2)
		got := Vector3Max(vec1, vec2)
		if !testVector3Equals(want, got) {
			t.Errorf("got %v; want %v", got, want)
		}
	})
}

func BenchmarkVector3Min(b *testing.B) {
	vec1 := NewVector3(1, 2, 3)
	vec2 := NewVector3(1, 2, 3)
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cVector3Min(vec1, vec2)
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			Vector3Min(vec1, vec2)
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func FuzzVector3Min(f *testing.F) {
	f.Add(
		float32(1), float32(2), float32(3),
		float32(1), float32(2), float32(3),
	)
	f.Fuzz(func(t *testing.T,
		vec1X, vec1Y, vec1Z float32,
		vec2X, vec2Y, vec2Z float32,
	) {
		vec1 := NewVector3(vec1X, vec1Y, vec1Z)
		vec2 := NewVector3(vec2X, vec2Y, vec2Z)
		want := cVector3Min(vec1, vec2)
		got := Vector3Min(vec1, vec2)
		if !testVector3Equals(want, got) {
			t.Errorf("got %v; want %v", got, want)
		}
	})
}

func BenchmarkVector3Multiply(b *testing.B) {
	v1 := NewVector3(1, 2, 3)
	v2 := NewVector3(1, 2, 3)
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cVector3Multiply(v1, v2)
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			Vector3Multiply(v1, v2)
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func FuzzVector3Multiply(f *testing.F) {
	f.Add(
		float32(1), float32(2), float32(3),
		float32(1), float32(2), float32(3),
	)
	f.Fuzz(func(t *testing.T,
		v1X, v1Y, v1Z float32,
		v2X, v2Y, v2Z float32,
	) {
		v1 := NewVector3(v1X, v1Y, v1Z)
		v2 := NewVector3(v2X, v2Y, v2Z)
		want := cVector3Multiply(v1, v2)
		got := Vector3Multiply(v1, v2)
		if !testVector3Equals(want, got) {
			t.Errorf("got %v; want %v", got, want)
		}
	})
}

func BenchmarkVector3Negate(b *testing.B) {
	v := NewVector3(1, 2, 3)
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cVector3Negate(v)
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			Vector3Negate(v)
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func FuzzVector3Negate(f *testing.F) {
	f.Add(
		float32(1), float32(2), float32(3),
	)
	f.Fuzz(func(t *testing.T,
		vX, vY, vZ float32,
	) {
		v := NewVector3(vX, vY, vZ)
		want := cVector3Negate(v)
		got := Vector3Negate(v)
		if !testVector3Equals(want, got) {
			t.Errorf("got %v; want %v", got, want)
		}
	})
}

func BenchmarkVector3Normalize(b *testing.B) {
	v := NewVector3(1, 2, 3)
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cVector3Normalize(v)
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			Vector3Normalize(v)
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func FuzzVector3Normalize(f *testing.F) {
	f.Add(
		float32(1), float32(2), float32(3),
	)
	f.Fuzz(func(t *testing.T,
		vX, vY, vZ float32,
	) {
		v := NewVector3(vX, vY, vZ)
		want := cVector3Normalize(v)
		got := Vector3Normalize(v)
		if !testVector3Equals(want, got) {
			t.Errorf("got %v; want %v", got, want)
		}
	})
}

func BenchmarkVector3One(b *testing.B) {
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cVector3One()
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			Vector3One()
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func TestVector3One(t *testing.T) {
	want := cVector3One()
	got := Vector3One()
	if !testVector3Equals(want, got) {
		t.Errorf("got %v; want %v", got, want)
	}
}

func BenchmarkVector3Perpendicular(b *testing.B) {
	v := NewVector3(1, 2, 3)
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cVector3Perpendicular(v)
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			Vector3Perpendicular(v)
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func FuzzVector3Perpendicular(f *testing.F) {
	f.Add(
		float32(1), float32(2), float32(3),
	)
	f.Fuzz(func(t *testing.T,
		vX, vY, vZ float32,
	) {
		v := NewVector3(vX, vY, vZ)
		want := cVector3Perpendicular(v)
		got := Vector3Perpendicular(v)
		if !testVector3Equals(want, got) {
			t.Errorf("got %v; want %v", got, want)
		}
	})
}

func BenchmarkVector3Project(b *testing.B) {
	v1 := NewVector3(1, 2, 3)
	v2 := NewVector3(1, 2, 3)
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cVector3Project(v1, v2)
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			Vector3Project(v1, v2)
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func FuzzVector3Project(f *testing.F) {
	f.Add(
		float32(1), float32(2), float32(3),
		float32(1), float32(2), float32(3),
	)
	f.Fuzz(func(t *testing.T,
		v1X, v1Y, v1Z float32,
		v2X, v2Y, v2Z float32,
	) {
		v1 := NewVector3(v1X, v1Y, v1Z)
		v2 := NewVector3(v2X, v2Y, v2Z)
		want := cVector3Project(v1, v2)
		got := Vector3Project(v1, v2)
		if !testVector3Equals(want, got) {
			t.Errorf("got %v; want %v", got, want)
		}
	})
}

func BenchmarkVector3Reflect(b *testing.B) {
	vector := NewVector3(1, 2, 3)
	normal := NewVector3(1, 2, 3)
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cVector3Reflect(vector, normal)
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			Vector3Reflect(vector, normal)
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func FuzzVector3Reflect(f *testing.F) {
	f.Add(
		float32(1), float32(2), float32(3),
		float32(1), float32(2), float32(3),
	)
	f.Fuzz(func(t *testing.T,
		vectorX, vectorY, vectorZ float32,
		normalX, normalY, normalZ float32,
	) {
		vector := NewVector3(vectorX, vectorY, vectorZ)
		normal := NewVector3(normalX, normalY, normalZ)
		want := cVector3Reflect(vector, normal)
		got := Vector3Reflect(vector, normal)
		if !testVector3Equals(want, got) {
			t.Errorf("got %v; want %v", got, want)
		}
	})
}

func BenchmarkVector3Refract(b *testing.B) {
	v := NewVector3(1, 2, 3)
	n := NewVector3(1, 2, 3)
	r := float32(1)
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cVector3Refract(v, n, r)
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			Vector3Refract(v, n, r)
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func FuzzVector3Refract(f *testing.F) {
	f.Add(
		float32(1), float32(2), float32(3),
		float32(1), float32(2), float32(3),
		float32(1),
	)
	f.Fuzz(func(t *testing.T,
		vX, vY, vZ float32,
		nX, nY, nZ float32,
		r float32,
	) {
		v := NewVector3(vX, vY, vZ)
		n := NewVector3(nX, nY, nZ)
		want := cVector3Refract(v, n, r)
		got := Vector3Refract(v, n, r)
		if !testVector3Equals(want, got) {
			t.Errorf("got %v; want %v", got, want)
		}
	})
}

func BenchmarkVector3Reject(b *testing.B) {
	v1 := NewVector3(1, 2, 3)
	v2 := NewVector3(1, 2, 3)
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cVector3Reject(v1, v2)
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			Vector3Reject(v1, v2)
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func FuzzVector3Reject(f *testing.F) {
	f.Add(
		float32(1), float32(2), float32(3),
		float32(1), float32(2), float32(3),
	)
	f.Fuzz(func(t *testing.T,
		v1X, v1Y, v1Z float32,
		v2X, v2Y, v2Z float32,
	) {
		v1 := NewVector3(v1X, v1Y, v1Z)
		v2 := NewVector3(v2X, v2Y, v2Z)
		want := cVector3Reject(v1, v2)
		got := Vector3Reject(v1, v2)
		if !testVector3Equals(want, got) {
			t.Errorf("got %v; want %v", got, want)
		}
	})
}

func BenchmarkVector3RotateByAxisAngle(b *testing.B) {
	v := NewVector3(1, 2, 3)
	axis := NewVector3(1, 2, 3)
	angle := float32(1)
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cVector3RotateByAxisAngle(v, axis, angle)
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			Vector3RotateByAxisAngle(v, axis, angle)
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func FuzzVector3RotateByAxisAngle(f *testing.F) {
	f.Add(
		float32(1), float32(2), float32(3),
		float32(1), float32(2), float32(3),
		float32(1),
	)
	f.Fuzz(func(t *testing.T,
		vX, vY, vZ float32,
		axisX, axisY, axisZ float32,
		angle float32,
	) {
		v := NewVector3(vX, vY, vZ)
		v = Vector3Normalize(v)
		axis := NewVector3(axisX, axisY, axisZ)
		axis = Vector3Normalize(axis)
		want := cVector3RotateByAxisAngle(v, axis, angle)
		got := Vector3RotateByAxisAngle(v, axis, angle)
		if !testVector3Equals(want, got) {
			t.Errorf("got %v; want %v", got, want)
		}
	})
}

func BenchmarkVector3RotateByQuaternion(b *testing.B) {
	v := NewVector3(1, 2, 3)
	q := NewQuaternion(1, 2, 3, 4)
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cVector3RotateByQuaternion(v, q)
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			Vector3RotateByQuaternion(v, q)
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func FuzzVector3RotateByQuaternion(f *testing.F) {
	f.Add(
		float32(1), float32(2), float32(3),
		float32(1), float32(2), float32(3), float32(4),
	)
	f.Fuzz(func(t *testing.T,
		vX, vY, vZ float32,
		qX, qY, qZ, qW float32,
	) {
		v := NewVector3(vX, vY, vZ)
		q := NewQuaternion(qX, qY, qZ, qW)
		want := cVector3RotateByQuaternion(v, q)
		got := Vector3RotateByQuaternion(v, q)
		if !testVector3Equals(want, got) {
			t.Errorf("got %v; want %v", got, want)
		}
	})
}

func BenchmarkVector3Scale(b *testing.B) {
	v := NewVector3(1, 2, 3)
	scale := float32(1)
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cVector3Scale(v, scale)
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			Vector3Scale(v, scale)
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func FuzzVector3Scale(f *testing.F) {
	f.Add(
		float32(1), float32(2), float32(3),
		float32(1),
	)
	f.Fuzz(func(t *testing.T,
		vX, vY, vZ float32,
		scale float32,
	) {
		v := NewVector3(vX, vY, vZ)
		want := cVector3Scale(v, scale)
		got := Vector3Scale(v, scale)
		if !testVector3Equals(want, got) {
			t.Errorf("got %v; want %v", got, want)
		}
	})
}

func BenchmarkVector3Subtract(b *testing.B) {
	v1 := NewVector3(1, 2, 3)
	v2 := NewVector3(1, 2, 3)
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cVector3Subtract(v1, v2)
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			Vector3Subtract(v1, v2)
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func FuzzVector3Subtract(f *testing.F) {
	f.Add(
		float32(1), float32(2), float32(3),
		float32(1), float32(2), float32(3),
	)
	f.Fuzz(func(t *testing.T,
		v1X, v1Y, v1Z float32,
		v2X, v2Y, v2Z float32,
	) {
		v1 := NewVector3(v1X, v1Y, v1Z)
		v2 := NewVector3(v2X, v2Y, v2Z)
		want := cVector3Subtract(v1, v2)
		got := Vector3Subtract(v1, v2)
		if !testVector3Equals(want, got) {
			t.Errorf("got %v; want %v", got, want)
		}
	})
}

func BenchmarkVector3SubtractValue(b *testing.B) {
	v := NewVector3(1, 2, 3)
	sub := float32(1)
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cVector3SubtractValue(v, sub)
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			Vector3SubtractValue(v, sub)
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func FuzzVector3SubtractValue(f *testing.F) {
	f.Add(
		float32(1), float32(2), float32(3),
		float32(1),
	)
	f.Fuzz(func(t *testing.T,
		vX, vY, vZ float32,
		sub float32,
	) {
		v := NewVector3(vX, vY, vZ)
		want := cVector3SubtractValue(v, sub)
		got := Vector3SubtractValue(v, sub)
		if !testVector3Equals(want, got) {
			t.Errorf("got %v; want %v", got, want)
		}
	})
}

func BenchmarkVector3ToFloatV(b *testing.B) {
	v := NewVector3(1, 2, 3)
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cVector3ToFloatV(v)
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			Vector3ToFloatV(v)
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func FuzzVector3ToFloatV(f *testing.F) {
	f.Add(
		float32(1), float32(2), float32(3),
	)
	f.Fuzz(func(t *testing.T,
		vX, vY, vZ float32,
	) {
		v := NewVector3(vX, vY, vZ)
		want := cVector3ToFloatV(v)
		got := Vector3ToFloatV(v)
		if !testFloat32SliceEquals(want[:], got[:]) {
			t.Errorf("got %v; want %v", got, want)
		}
	})
}

func BenchmarkVector3Transform(b *testing.B) {
	v := NewVector3(1, 2, 3)
	mat := NewMatrix(1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4)
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cVector3Transform(v, mat)
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			Vector3Transform(v, mat)
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func FuzzVector3Transform(f *testing.F) {
	f.Add(
		float32(1), float32(2), float32(3),
		float32(1), float32(2), float32(3), float32(4),
		float32(1), float32(2), float32(3), float32(4),
		float32(1), float32(2), float32(3), float32(4),
		float32(1), float32(2), float32(3), float32(4),
	)
	f.Fuzz(func(t *testing.T,
		vX, vY, vZ float32,
		matM0, matM4, matM8, matM12,
		matM1, matM5, matM9, matM13,
		matM2, matM6, matM10, matM14,
		matM3, matM7, matM11, matM15 float32,
	) {
		v := NewVector3(vX, vY, vZ)
		mat := NewMatrix(
			matM0, matM4, matM8, matM12,
			matM1, matM5, matM9, matM13,
			matM2, matM6, matM10, matM14,
			matM3, matM7, matM11, matM15,
		)
		want := cVector3Transform(v, mat)
		got := Vector3Transform(v, mat)
		if !testVector3Equals(want, got) {
			t.Errorf("got %v; want %v", got, want)
		}
	})
}

func BenchmarkVector3Unproject(b *testing.B) {
	source := NewVector3(1, 2, 3)
	projection := NewMatrix(1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4)
	view := NewMatrix(1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4)
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cVector3Unproject(source, projection, view)
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			Vector3Unproject(source, projection, view)
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func FuzzVector3Unproject(f *testing.F) {
	f.Add(
		float32(1), float32(2), float32(3),
		float32(1), float32(2), float32(3), float32(4),
		float32(1), float32(2), float32(3), float32(4),
		float32(1), float32(2), float32(3), float32(4),
		float32(1), float32(2), float32(3), float32(4),
		float32(1), float32(2), float32(3), float32(4),
		float32(1), float32(2), float32(3), float32(4),
		float32(1), float32(2), float32(3), float32(4),
		float32(1), float32(2), float32(3), float32(4),
	)
	f.Fuzz(func(t *testing.T,
		sourceX, sourceY, sourceZ float32,
		projectionM0, projectionM4, projectionM8, projectionM12,
		projectionM1, projectionM5, projectionM9, projectionM13,
		projectionM2, projectionM6, projectionM10, projectionM14,
		projectionM3, projectionM7, projectionM11, projectionM15 float32,
		viewM0, viewM4, viewM8, viewM12,
		viewM1, viewM5, viewM9, viewM13,
		viewM2, viewM6, viewM10, viewM14,
		viewM3, viewM7, viewM11, viewM15 float32,
	) {
		source := NewVector3(sourceX, sourceY, sourceZ)
		projection := NewMatrix(
			projectionM0, projectionM4, projectionM8, projectionM12,
			projectionM1, projectionM5, projectionM9, projectionM13,
			projectionM2, projectionM6, projectionM10, projectionM14,
			projectionM3, projectionM7, projectionM11, projectionM15,
		)
		view := NewMatrix(
			viewM0, viewM4, viewM8, viewM12,
			viewM1, viewM5, viewM9, viewM13,
			viewM2, viewM6, viewM10, viewM14,
			viewM3, viewM7, viewM11, viewM15,
		)
		want := cVector3Unproject(source, projection, view)
		got := Vector3Unproject(source, projection, view)
		if !testVector3Equals(want, got) {
			t.Errorf("got %v; want %v", got, want)
		}
	})
}

func BenchmarkVector3Zero(b *testing.B) {
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cVector3Zero()
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			Vector3Zero()
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func TestVector3Zero(t *testing.T) {
	want := cVector3Zero()
	got := Vector3Zero()
	if !testVector3Equals(want, got) {
		t.Errorf("got %v; want %v", got, want)
	}
}

func BenchmarkWrap(b *testing.B) {
	value := float32(1)
	min := float32(2)
	max := float32(3)
	var (
		perCCall  time.Duration
		perGoCall time.Duration
	)
	b.Run("c", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			cWrap(value, min, max)
		}
		perCCall = b.Elapsed() / time.Duration(b.N)
	})
	b.Run("go", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			Wrap(value, min, max)
		}
		perGoCall = b.Elapsed() / time.Duration(b.N)
	})
	if perCCall < perGoCall {
		b.Log("Go slower than C")
	}
}

func FuzzWrap(f *testing.F) {
	f.Add(
		float32(1),
		float32(2),
		float32(3),
	)
	f.Fuzz(func(t *testing.T,
		value float32,
		min float32,
		max float32,
	) {
		want := cWrap(value, min, max)
		got := Wrap(value, min, max)
		if !testFloat32Equals(want, got) {
			t.Errorf("got %v; want %v", got, want)
		}
	})
}

// helpers

func testFloat32Equals(a, b float32) bool {
	if math.IsNaN(float64(a)) && math.IsNaN(float64(b)) {
		return true
	}
	if math.IsInf(float64(a), 1) && math.IsInf(float64(b), 1) {
		return true
	}
	if math.IsInf(float64(a), -1) && math.IsInf(float64(b), -1) {
		return true
	}
	return math.Abs(float64(a-b)) <= epsilon*math.Max(1.0, math.Max(math.Abs(float64(a)), math.Abs(float64(b))))
}

func testFloat32SliceEquals(a, b []float32) bool {
	if len(a) != len(b) {
		return false
	}
	for i := range a {
		if !testFloat32Equals(a[i], b[i]) {
			return false
		}
	}
	return true
}

func testVector2Equals(a, b Vector2) bool {
	return testFloat32Equals(a.X, b.X) &&
		testFloat32Equals(a.Y, b.Y)
}

func testVector3Equals(a, b Vector3) bool {
	return testFloat32Equals(a.X, b.X) &&
		testFloat32Equals(a.Y, b.Y) &&
		testFloat32Equals(a.Z, b.Z)
}

func testQuaternionEquals(a, b Quaternion) bool {
	return testFloat32Equals(a.X, b.X) &&
		testFloat32Equals(a.Y, b.Y) &&
		testFloat32Equals(a.Z, b.Z) &&
		testFloat32Equals(a.W, b.W)
}

func testMatrixEquals(a, b Matrix) bool {
	return testFloat32Equals(a.M0, b.M0) &&
		testFloat32Equals(a.M1, b.M1) &&
		testFloat32Equals(a.M2, b.M2) &&
		testFloat32Equals(a.M3, b.M3) &&
		testFloat32Equals(a.M4, b.M4) &&
		testFloat32Equals(a.M5, b.M5) &&
		testFloat32Equals(a.M6, b.M6) &&
		testFloat32Equals(a.M7, b.M7) &&
		testFloat32Equals(a.M8, b.M8) &&
		testFloat32Equals(a.M9, b.M9) &&
		testFloat32Equals(a.M10, b.M10) &&
		testFloat32Equals(a.M11, b.M11) &&
		testFloat32Equals(a.M12, b.M12) &&
		testFloat32Equals(a.M13, b.M13) &&
		testFloat32Equals(a.M14, b.M14) &&
		testFloat32Equals(a.M15, b.M15)
}
