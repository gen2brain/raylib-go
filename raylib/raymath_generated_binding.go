// Code generated by ./internal/cmd/genraymath DO NOT EDIT.

package rl

//#include "raymath.h"
import "C"

import "unsafe"

func cClamp(value, min, max float32) float32 {
	cvalue := C.float(value)
	cmin := C.float(min)
	cmax := C.float(max)
	ret := C.Clamp(cvalue, cmin, cmax)
	return float32(ret)
}

func cFloatEquals(x, y float32) bool {
	cx := C.float(x)
	cy := C.float(y)
	ret := C.FloatEquals(cx, cy)
	return ret != 0
}

func cLerp(start, end, amount float32) float32 {
	cstart := C.float(start)
	cend := C.float(end)
	camount := C.float(amount)
	ret := C.Lerp(cstart, cend, camount)
	return float32(ret)
}

func cMatrixAdd(left, right Matrix) Matrix {
	cleft := *(*C.Matrix)(unsafe.Pointer(&left))
	cright := *(*C.Matrix)(unsafe.Pointer(&right))
	ret := C.MatrixAdd(cleft, cright)
	return *(*Matrix)(unsafe.Pointer(&ret))
}

func cMatrixDecompose(mat Matrix, translation *Vector3, rotation *Quaternion, scale *Vector3) {
	cmat := *(*C.Matrix)(unsafe.Pointer(&mat))
	ctranslation := (*C.Vector3)(unsafe.Pointer(translation))
	crotation := (*C.Quaternion)(unsafe.Pointer(rotation))
	cscale := (*C.Vector3)(unsafe.Pointer(scale))
	C.MatrixDecompose(cmat, ctranslation, crotation, cscale)
}

func cMatrixDeterminant(mat Matrix) float32 {
	cmat := *(*C.Matrix)(unsafe.Pointer(&mat))
	ret := C.MatrixDeterminant(cmat)
	return float32(ret)
}

func cMatrixFrustum(left, right, bottom, top, nearPlane, farPlane float32) Matrix {
	cleft := C.double(left)
	cright := C.double(right)
	cbottom := C.double(bottom)
	ctop := C.double(top)
	cnearPlane := C.double(nearPlane)
	cfarPlane := C.double(farPlane)
	ret := C.MatrixFrustum(cleft, cright, cbottom, ctop, cnearPlane, cfarPlane)
	return *(*Matrix)(unsafe.Pointer(&ret))
}

func cMatrixIdentity() Matrix {
	ret := C.MatrixIdentity()
	return *(*Matrix)(unsafe.Pointer(&ret))
}

func cMatrixInvert(mat Matrix) Matrix {
	cmat := *(*C.Matrix)(unsafe.Pointer(&mat))
	ret := C.MatrixInvert(cmat)
	return *(*Matrix)(unsafe.Pointer(&ret))
}

func cMatrixLookAt(eye, target, up Vector3) Matrix {
	ceye := *(*C.Vector3)(unsafe.Pointer(&eye))
	ctarget := *(*C.Vector3)(unsafe.Pointer(&target))
	cup := *(*C.Vector3)(unsafe.Pointer(&up))
	ret := C.MatrixLookAt(ceye, ctarget, cup)
	return *(*Matrix)(unsafe.Pointer(&ret))
}

func cMatrixMultiply(left, right Matrix) Matrix {
	cleft := *(*C.Matrix)(unsafe.Pointer(&left))
	cright := *(*C.Matrix)(unsafe.Pointer(&right))
	ret := C.MatrixMultiply(cleft, cright)
	return *(*Matrix)(unsafe.Pointer(&ret))
}

func cMatrixOrtho(left, right, bottom, top, near, far float32) Matrix {
	cleft := C.double(left)
	cright := C.double(right)
	cbottom := C.double(bottom)
	ctop := C.double(top)
	cnear := C.double(near)
	cfar := C.double(far)
	ret := C.MatrixOrtho(cleft, cright, cbottom, ctop, cnear, cfar)
	return *(*Matrix)(unsafe.Pointer(&ret))
}

func cMatrixPerspective(fovY, aspect, nearPlane, farPlane float32) Matrix {
	cfovY := C.double(fovY)
	caspect := C.double(aspect)
	cnearPlane := C.double(nearPlane)
	cfarPlane := C.double(farPlane)
	ret := C.MatrixPerspective(cfovY, caspect, cnearPlane, cfarPlane)
	return *(*Matrix)(unsafe.Pointer(&ret))
}

func cMatrixRotate(axis Vector3, angle float32) Matrix {
	caxis := *(*C.Vector3)(unsafe.Pointer(&axis))
	cangle := C.float(angle)
	ret := C.MatrixRotate(caxis, cangle)
	return *(*Matrix)(unsafe.Pointer(&ret))
}

func cMatrixRotateX(angle float32) Matrix {
	cangle := C.float(angle)
	ret := C.MatrixRotateX(cangle)
	return *(*Matrix)(unsafe.Pointer(&ret))
}

func cMatrixRotateXYZ(angle Vector3) Matrix {
	cangle := *(*C.Vector3)(unsafe.Pointer(&angle))
	ret := C.MatrixRotateXYZ(cangle)
	return *(*Matrix)(unsafe.Pointer(&ret))
}

func cMatrixRotateY(angle float32) Matrix {
	cangle := C.float(angle)
	ret := C.MatrixRotateY(cangle)
	return *(*Matrix)(unsafe.Pointer(&ret))
}

func cMatrixRotateZ(angle float32) Matrix {
	cangle := C.float(angle)
	ret := C.MatrixRotateZ(cangle)
	return *(*Matrix)(unsafe.Pointer(&ret))
}

func cMatrixRotateZYX(angle Vector3) Matrix {
	cangle := *(*C.Vector3)(unsafe.Pointer(&angle))
	ret := C.MatrixRotateZYX(cangle)
	return *(*Matrix)(unsafe.Pointer(&ret))
}

func cMatrixScale(x, y, z float32) Matrix {
	cx := C.float(x)
	cy := C.float(y)
	cz := C.float(z)
	ret := C.MatrixScale(cx, cy, cz)
	return *(*Matrix)(unsafe.Pointer(&ret))
}

func cMatrixSubtract(left, right Matrix) Matrix {
	cleft := *(*C.Matrix)(unsafe.Pointer(&left))
	cright := *(*C.Matrix)(unsafe.Pointer(&right))
	ret := C.MatrixSubtract(cleft, cright)
	return *(*Matrix)(unsafe.Pointer(&ret))
}

func cMatrixToFloatV(mat Matrix) [16]float32 {
	cmat := *(*C.Matrix)(unsafe.Pointer(&mat))
	ret := C.MatrixToFloatV(cmat)
	return *(*[16]float32)(unsafe.Pointer(&ret))
}

func cMatrixTrace(mat Matrix) float32 {
	cmat := *(*C.Matrix)(unsafe.Pointer(&mat))
	ret := C.MatrixTrace(cmat)
	return float32(ret)
}

func cMatrixTranslate(x, y, z float32) Matrix {
	cx := C.float(x)
	cy := C.float(y)
	cz := C.float(z)
	ret := C.MatrixTranslate(cx, cy, cz)
	return *(*Matrix)(unsafe.Pointer(&ret))
}

func cMatrixTranspose(mat Matrix) Matrix {
	cmat := *(*C.Matrix)(unsafe.Pointer(&mat))
	ret := C.MatrixTranspose(cmat)
	return *(*Matrix)(unsafe.Pointer(&ret))
}

func cNormalize(value, start, end float32) float32 {
	cvalue := C.float(value)
	cstart := C.float(start)
	cend := C.float(end)
	ret := C.Normalize(cvalue, cstart, cend)
	return float32(ret)
}

func cQuaternionAdd(q1 Quaternion, q2 Quaternion) Quaternion {
	cq1 := *(*C.Quaternion)(unsafe.Pointer(&q1))
	cq2 := *(*C.Quaternion)(unsafe.Pointer(&q2))
	ret := C.QuaternionAdd(cq1, cq2)
	return *(*Quaternion)(unsafe.Pointer(&ret))
}

func cQuaternionAddValue(q Quaternion, add float32) Quaternion {
	cq := *(*C.Quaternion)(unsafe.Pointer(&q))
	cadd := C.float(add)
	ret := C.QuaternionAddValue(cq, cadd)
	return *(*Quaternion)(unsafe.Pointer(&ret))
}

func cQuaternionDivide(q1 Quaternion, q2 Quaternion) Quaternion {
	cq1 := *(*C.Quaternion)(unsafe.Pointer(&q1))
	cq2 := *(*C.Quaternion)(unsafe.Pointer(&q2))
	ret := C.QuaternionDivide(cq1, cq2)
	return *(*Quaternion)(unsafe.Pointer(&ret))
}

func cQuaternionEquals(q, p Quaternion) bool {
	cq := *(*C.Quaternion)(unsafe.Pointer(&q))
	cp := *(*C.Quaternion)(unsafe.Pointer(&p))
	ret := C.QuaternionEquals(cq, cp)
	return ret != 0
}

func cQuaternionFromAxisAngle(axis Vector3, angle float32) Quaternion {
	caxis := *(*C.Vector3)(unsafe.Pointer(&axis))
	cangle := C.float(angle)
	ret := C.QuaternionFromAxisAngle(caxis, cangle)
	return *(*Quaternion)(unsafe.Pointer(&ret))
}

func cQuaternionFromEuler(pitch, yaw, roll float32) Quaternion {
	cpitch := C.float(pitch)
	cyaw := C.float(yaw)
	croll := C.float(roll)
	ret := C.QuaternionFromEuler(cpitch, cyaw, croll)
	return *(*Quaternion)(unsafe.Pointer(&ret))
}

func cQuaternionFromMatrix(mat Matrix) Quaternion {
	cmat := *(*C.Matrix)(unsafe.Pointer(&mat))
	ret := C.QuaternionFromMatrix(cmat)
	return *(*Quaternion)(unsafe.Pointer(&ret))
}

func cQuaternionFromVector3ToVector3(from Vector3, to Vector3) Quaternion {
	cfrom := *(*C.Vector3)(unsafe.Pointer(&from))
	cto := *(*C.Vector3)(unsafe.Pointer(&to))
	ret := C.QuaternionFromVector3ToVector3(cfrom, cto)
	return *(*Quaternion)(unsafe.Pointer(&ret))
}

func cQuaternionIdentity() Quaternion {
	ret := C.QuaternionIdentity()
	return *(*Quaternion)(unsafe.Pointer(&ret))
}

func cQuaternionInvert(quat Quaternion) Quaternion {
	cquat := *(*C.Quaternion)(unsafe.Pointer(&quat))
	ret := C.QuaternionInvert(cquat)
	return *(*Quaternion)(unsafe.Pointer(&ret))
}

func cQuaternionLength(quat Quaternion) float32 {
	cquat := *(*C.Quaternion)(unsafe.Pointer(&quat))
	ret := C.QuaternionLength(cquat)
	return float32(ret)
}

func cQuaternionLerp(q1 Quaternion, q2 Quaternion, amount float32) Quaternion {
	cq1 := *(*C.Quaternion)(unsafe.Pointer(&q1))
	cq2 := *(*C.Quaternion)(unsafe.Pointer(&q2))
	camount := C.float(amount)
	ret := C.QuaternionLerp(cq1, cq2, camount)
	return *(*Quaternion)(unsafe.Pointer(&ret))
}

func cQuaternionMultiply(q1, q2 Quaternion) Quaternion {
	cq1 := *(*C.Quaternion)(unsafe.Pointer(&q1))
	cq2 := *(*C.Quaternion)(unsafe.Pointer(&q2))
	ret := C.QuaternionMultiply(cq1, cq2)
	return *(*Quaternion)(unsafe.Pointer(&ret))
}

func cQuaternionNlerp(q1 Quaternion, q2 Quaternion, amount float32) Quaternion {
	cq1 := *(*C.Quaternion)(unsafe.Pointer(&q1))
	cq2 := *(*C.Quaternion)(unsafe.Pointer(&q2))
	camount := C.float(amount)
	ret := C.QuaternionNlerp(cq1, cq2, camount)
	return *(*Quaternion)(unsafe.Pointer(&ret))
}

func cQuaternionNormalize(q Quaternion) Quaternion {
	cq := *(*C.Quaternion)(unsafe.Pointer(&q))
	ret := C.QuaternionNormalize(cq)
	return *(*Quaternion)(unsafe.Pointer(&ret))
}

func cQuaternionScale(q Quaternion, mul float32) Quaternion {
	cq := *(*C.Quaternion)(unsafe.Pointer(&q))
	cmul := C.float(mul)
	ret := C.QuaternionScale(cq, cmul)
	return *(*Quaternion)(unsafe.Pointer(&ret))
}

func cQuaternionSlerp(q1, q2 Quaternion, amount float32) Quaternion {
	cq1 := *(*C.Quaternion)(unsafe.Pointer(&q1))
	cq2 := *(*C.Quaternion)(unsafe.Pointer(&q2))
	camount := C.float(amount)
	ret := C.QuaternionSlerp(cq1, cq2, camount)
	return *(*Quaternion)(unsafe.Pointer(&ret))
}

func cQuaternionSubtract(q1 Quaternion, q2 Quaternion) Quaternion {
	cq1 := *(*C.Quaternion)(unsafe.Pointer(&q1))
	cq2 := *(*C.Quaternion)(unsafe.Pointer(&q2))
	ret := C.QuaternionSubtract(cq1, cq2)
	return *(*Quaternion)(unsafe.Pointer(&ret))
}

func cQuaternionSubtractValue(q Quaternion, sub float32) Quaternion {
	cq := *(*C.Quaternion)(unsafe.Pointer(&q))
	csub := C.float(sub)
	ret := C.QuaternionSubtractValue(cq, csub)
	return *(*Quaternion)(unsafe.Pointer(&ret))
}

func cQuaternionToAxisAngle(q Quaternion, outAxis *Vector3, outAngle *float32) {
	cq := *(*C.Quaternion)(unsafe.Pointer(&q))
	coutAxis := (*C.Vector3)(unsafe.Pointer(outAxis))
	coutAngle := (*C.float)(outAngle)
	C.QuaternionToAxisAngle(cq, coutAxis, coutAngle)
}

func cQuaternionToEuler(q Quaternion) Vector3 {
	cq := *(*C.Quaternion)(unsafe.Pointer(&q))
	ret := C.QuaternionToEuler(cq)
	return *(*Vector3)(unsafe.Pointer(&ret))
}

func cQuaternionToMatrix(q Quaternion) Matrix {
	cq := *(*C.Quaternion)(unsafe.Pointer(&q))
	ret := C.QuaternionToMatrix(cq)
	return *(*Matrix)(unsafe.Pointer(&ret))
}

func cQuaternionTransform(q Quaternion, mat Matrix) Quaternion {
	cq := *(*C.Quaternion)(unsafe.Pointer(&q))
	cmat := *(*C.Matrix)(unsafe.Pointer(&mat))
	ret := C.QuaternionTransform(cq, cmat)
	return *(*Quaternion)(unsafe.Pointer(&ret))
}

func cRemap(value, inputStart, inputEnd, outputStart, outputEnd float32) float32 {
	cvalue := C.float(value)
	cinputStart := C.float(inputStart)
	cinputEnd := C.float(inputEnd)
	coutputStart := C.float(outputStart)
	coutputEnd := C.float(outputEnd)
	ret := C.Remap(cvalue, cinputStart, cinputEnd, coutputStart, coutputEnd)
	return float32(ret)
}

func cVector2Add(v1, v2 Vector2) Vector2 {
	cv1 := *(*C.Vector2)(unsafe.Pointer(&v1))
	cv2 := *(*C.Vector2)(unsafe.Pointer(&v2))
	ret := C.Vector2Add(cv1, cv2)
	return *(*Vector2)(unsafe.Pointer(&ret))
}

func cVector2AddValue(v Vector2, add float32) Vector2 {
	cv := *(*C.Vector2)(unsafe.Pointer(&v))
	cadd := C.float(add)
	ret := C.Vector2AddValue(cv, cadd)
	return *(*Vector2)(unsafe.Pointer(&ret))
}

func cVector2Angle(v1, v2 Vector2) float32 {
	cv1 := *(*C.Vector2)(unsafe.Pointer(&v1))
	cv2 := *(*C.Vector2)(unsafe.Pointer(&v2))
	ret := C.Vector2Angle(cv1, cv2)
	return float32(ret)
}

func cVector2Clamp(v Vector2, min Vector2, max Vector2) Vector2 {
	cv := *(*C.Vector2)(unsafe.Pointer(&v))
	cmin := *(*C.Vector2)(unsafe.Pointer(&min))
	cmax := *(*C.Vector2)(unsafe.Pointer(&max))
	ret := C.Vector2Clamp(cv, cmin, cmax)
	return *(*Vector2)(unsafe.Pointer(&ret))
}

func cVector2ClampValue(v Vector2, min float32, max float32) Vector2 {
	cv := *(*C.Vector2)(unsafe.Pointer(&v))
	cmin := C.float(min)
	cmax := C.float(max)
	ret := C.Vector2ClampValue(cv, cmin, cmax)
	return *(*Vector2)(unsafe.Pointer(&ret))
}

func cVector2CrossProduct(v1, v2 Vector2) float32 {
	cv1 := *(*C.Vector2)(unsafe.Pointer(&v1))
	cv2 := *(*C.Vector2)(unsafe.Pointer(&v2))
	ret := C.Vector2CrossProduct(cv1, cv2)
	return float32(ret)
}

func cVector2Distance(v1, v2 Vector2) float32 {
	cv1 := *(*C.Vector2)(unsafe.Pointer(&v1))
	cv2 := *(*C.Vector2)(unsafe.Pointer(&v2))
	ret := C.Vector2Distance(cv1, cv2)
	return float32(ret)
}

func cVector2DistanceSqr(v1 Vector2, v2 Vector2) float32 {
	cv1 := *(*C.Vector2)(unsafe.Pointer(&v1))
	cv2 := *(*C.Vector2)(unsafe.Pointer(&v2))
	ret := C.Vector2DistanceSqr(cv1, cv2)
	return float32(ret)
}

func cVector2Divide(v1, v2 Vector2) Vector2 {
	cv1 := *(*C.Vector2)(unsafe.Pointer(&v1))
	cv2 := *(*C.Vector2)(unsafe.Pointer(&v2))
	ret := C.Vector2Divide(cv1, cv2)
	return *(*Vector2)(unsafe.Pointer(&ret))
}

func cVector2DotProduct(v1, v2 Vector2) float32 {
	cv1 := *(*C.Vector2)(unsafe.Pointer(&v1))
	cv2 := *(*C.Vector2)(unsafe.Pointer(&v2))
	ret := C.Vector2DotProduct(cv1, cv2)
	return float32(ret)
}

func cVector2Equals(p Vector2, q Vector2) bool {
	cp := *(*C.Vector2)(unsafe.Pointer(&p))
	cq := *(*C.Vector2)(unsafe.Pointer(&q))
	ret := C.Vector2Equals(cp, cq)
	return ret != 0
}

func cVector2Invert(v Vector2) Vector2 {
	cv := *(*C.Vector2)(unsafe.Pointer(&v))
	ret := C.Vector2Invert(cv)
	return *(*Vector2)(unsafe.Pointer(&ret))
}

func cVector2Length(v Vector2) float32 {
	cv := *(*C.Vector2)(unsafe.Pointer(&v))
	ret := C.Vector2Length(cv)
	return float32(ret)
}

func cVector2LengthSqr(v Vector2) float32 {
	cv := *(*C.Vector2)(unsafe.Pointer(&v))
	ret := C.Vector2LengthSqr(cv)
	return float32(ret)
}

func cVector2Lerp(v1, v2 Vector2, amount float32) Vector2 {
	cv1 := *(*C.Vector2)(unsafe.Pointer(&v1))
	cv2 := *(*C.Vector2)(unsafe.Pointer(&v2))
	camount := C.float(amount)
	ret := C.Vector2Lerp(cv1, cv2, camount)
	return *(*Vector2)(unsafe.Pointer(&ret))
}

func cVector2LineAngle(start Vector2, end Vector2) float32 {
	cstart := *(*C.Vector2)(unsafe.Pointer(&start))
	cend := *(*C.Vector2)(unsafe.Pointer(&end))
	ret := C.Vector2LineAngle(cstart, cend)
	return float32(ret)
}

func cVector2MoveTowards(v Vector2, target Vector2, maxDistance float32) Vector2 {
	cv := *(*C.Vector2)(unsafe.Pointer(&v))
	ctarget := *(*C.Vector2)(unsafe.Pointer(&target))
	cmaxDistance := C.float(maxDistance)
	ret := C.Vector2MoveTowards(cv, ctarget, cmaxDistance)
	return *(*Vector2)(unsafe.Pointer(&ret))
}

func cVector2Multiply(v1, v2 Vector2) Vector2 {
	cv1 := *(*C.Vector2)(unsafe.Pointer(&v1))
	cv2 := *(*C.Vector2)(unsafe.Pointer(&v2))
	ret := C.Vector2Multiply(cv1, cv2)
	return *(*Vector2)(unsafe.Pointer(&ret))
}

func cVector2Negate(v Vector2) Vector2 {
	cv := *(*C.Vector2)(unsafe.Pointer(&v))
	ret := C.Vector2Negate(cv)
	return *(*Vector2)(unsafe.Pointer(&ret))
}

func cVector2Normalize(v Vector2) Vector2 {
	cv := *(*C.Vector2)(unsafe.Pointer(&v))
	ret := C.Vector2Normalize(cv)
	return *(*Vector2)(unsafe.Pointer(&ret))
}

func cVector2One() Vector2 {
	ret := C.Vector2One()
	return *(*Vector2)(unsafe.Pointer(&ret))
}

func cVector2Reflect(v Vector2, normal Vector2) Vector2 {
	cv := *(*C.Vector2)(unsafe.Pointer(&v))
	cnormal := *(*C.Vector2)(unsafe.Pointer(&normal))
	ret := C.Vector2Reflect(cv, cnormal)
	return *(*Vector2)(unsafe.Pointer(&ret))
}

func cVector2Rotate(v Vector2, angle float32) Vector2 {
	cv := *(*C.Vector2)(unsafe.Pointer(&v))
	cangle := C.float(angle)
	ret := C.Vector2Rotate(cv, cangle)
	return *(*Vector2)(unsafe.Pointer(&ret))
}

func cVector2Scale(v Vector2, scale float32) Vector2 {
	cv := *(*C.Vector2)(unsafe.Pointer(&v))
	cscale := C.float(scale)
	ret := C.Vector2Scale(cv, cscale)
	return *(*Vector2)(unsafe.Pointer(&ret))
}

func cVector2Subtract(v1, v2 Vector2) Vector2 {
	cv1 := *(*C.Vector2)(unsafe.Pointer(&v1))
	cv2 := *(*C.Vector2)(unsafe.Pointer(&v2))
	ret := C.Vector2Subtract(cv1, cv2)
	return *(*Vector2)(unsafe.Pointer(&ret))
}

func cVector2SubtractValue(v Vector2, sub float32) Vector2 {
	cv := *(*C.Vector2)(unsafe.Pointer(&v))
	csub := C.float(sub)
	ret := C.Vector2SubtractValue(cv, csub)
	return *(*Vector2)(unsafe.Pointer(&ret))
}

func cVector2Transform(v Vector2, mat Matrix) Vector2 {
	cv := *(*C.Vector2)(unsafe.Pointer(&v))
	cmat := *(*C.Matrix)(unsafe.Pointer(&mat))
	ret := C.Vector2Transform(cv, cmat)
	return *(*Vector2)(unsafe.Pointer(&ret))
}

func cVector2Zero() Vector2 {
	ret := C.Vector2Zero()
	return *(*Vector2)(unsafe.Pointer(&ret))
}

func cVector3Add(v1, v2 Vector3) Vector3 {
	cv1 := *(*C.Vector3)(unsafe.Pointer(&v1))
	cv2 := *(*C.Vector3)(unsafe.Pointer(&v2))
	ret := C.Vector3Add(cv1, cv2)
	return *(*Vector3)(unsafe.Pointer(&ret))
}

func cVector3AddValue(v Vector3, add float32) Vector3 {
	cv := *(*C.Vector3)(unsafe.Pointer(&v))
	cadd := C.float(add)
	ret := C.Vector3AddValue(cv, cadd)
	return *(*Vector3)(unsafe.Pointer(&ret))
}

func cVector3Angle(v1 Vector3, v2 Vector3) float32 {
	cv1 := *(*C.Vector3)(unsafe.Pointer(&v1))
	cv2 := *(*C.Vector3)(unsafe.Pointer(&v2))
	ret := C.Vector3Angle(cv1, cv2)
	return float32(ret)
}

func cVector3Barycenter(p, a, b, c Vector3) Vector3 {
	cp := *(*C.Vector3)(unsafe.Pointer(&p))
	ca := *(*C.Vector3)(unsafe.Pointer(&a))
	cb := *(*C.Vector3)(unsafe.Pointer(&b))
	cc := *(*C.Vector3)(unsafe.Pointer(&c))
	ret := C.Vector3Barycenter(cp, ca, cb, cc)
	return *(*Vector3)(unsafe.Pointer(&ret))
}

func cVector3Clamp(v Vector3, min Vector3, max Vector3) Vector3 {
	cv := *(*C.Vector3)(unsafe.Pointer(&v))
	cmin := *(*C.Vector3)(unsafe.Pointer(&min))
	cmax := *(*C.Vector3)(unsafe.Pointer(&max))
	ret := C.Vector3Clamp(cv, cmin, cmax)
	return *(*Vector3)(unsafe.Pointer(&ret))
}

func cVector3ClampValue(v Vector3, min float32, max float32) Vector3 {
	cv := *(*C.Vector3)(unsafe.Pointer(&v))
	cmin := C.float(min)
	cmax := C.float(max)
	ret := C.Vector3ClampValue(cv, cmin, cmax)
	return *(*Vector3)(unsafe.Pointer(&ret))
}

func cVector3CrossProduct(v1, v2 Vector3) Vector3 {
	cv1 := *(*C.Vector3)(unsafe.Pointer(&v1))
	cv2 := *(*C.Vector3)(unsafe.Pointer(&v2))
	ret := C.Vector3CrossProduct(cv1, cv2)
	return *(*Vector3)(unsafe.Pointer(&ret))
}

func cVector3Distance(v1, v2 Vector3) float32 {
	cv1 := *(*C.Vector3)(unsafe.Pointer(&v1))
	cv2 := *(*C.Vector3)(unsafe.Pointer(&v2))
	ret := C.Vector3Distance(cv1, cv2)
	return float32(ret)
}

func cVector3DistanceSqr(v1 Vector3, v2 Vector3) float32 {
	cv1 := *(*C.Vector3)(unsafe.Pointer(&v1))
	cv2 := *(*C.Vector3)(unsafe.Pointer(&v2))
	ret := C.Vector3DistanceSqr(cv1, cv2)
	return float32(ret)
}

func cVector3Divide(v1 Vector3, v2 Vector3) Vector3 {
	cv1 := *(*C.Vector3)(unsafe.Pointer(&v1))
	cv2 := *(*C.Vector3)(unsafe.Pointer(&v2))
	ret := C.Vector3Divide(cv1, cv2)
	return *(*Vector3)(unsafe.Pointer(&ret))
}

func cVector3DotProduct(v1, v2 Vector3) float32 {
	cv1 := *(*C.Vector3)(unsafe.Pointer(&v1))
	cv2 := *(*C.Vector3)(unsafe.Pointer(&v2))
	ret := C.Vector3DotProduct(cv1, cv2)
	return float32(ret)
}

func cVector3Equals(p Vector3, q Vector3) bool {
	cp := *(*C.Vector3)(unsafe.Pointer(&p))
	cq := *(*C.Vector3)(unsafe.Pointer(&q))
	ret := C.Vector3Equals(cp, cq)
	return ret != 0
}

func cVector3Invert(v Vector3) Vector3 {
	cv := *(*C.Vector3)(unsafe.Pointer(&v))
	ret := C.Vector3Invert(cv)
	return *(*Vector3)(unsafe.Pointer(&ret))
}

func cVector3Length(v Vector3) float32 {
	cv := *(*C.Vector3)(unsafe.Pointer(&v))
	ret := C.Vector3Length(cv)
	return float32(ret)
}

func cVector3LengthSqr(v Vector3) float32 {
	cv := *(*C.Vector3)(unsafe.Pointer(&v))
	ret := C.Vector3LengthSqr(cv)
	return float32(ret)
}

func cVector3Lerp(v1, v2 Vector3, amount float32) Vector3 {
	cv1 := *(*C.Vector3)(unsafe.Pointer(&v1))
	cv2 := *(*C.Vector3)(unsafe.Pointer(&v2))
	camount := C.float(amount)
	ret := C.Vector3Lerp(cv1, cv2, camount)
	return *(*Vector3)(unsafe.Pointer(&ret))
}

func cVector3Max(vec1, vec2 Vector3) Vector3 {
	cvec1 := *(*C.Vector3)(unsafe.Pointer(&vec1))
	cvec2 := *(*C.Vector3)(unsafe.Pointer(&vec2))
	ret := C.Vector3Max(cvec1, cvec2)
	return *(*Vector3)(unsafe.Pointer(&ret))
}

func cVector3Min(vec1, vec2 Vector3) Vector3 {
	cvec1 := *(*C.Vector3)(unsafe.Pointer(&vec1))
	cvec2 := *(*C.Vector3)(unsafe.Pointer(&vec2))
	ret := C.Vector3Min(cvec1, cvec2)
	return *(*Vector3)(unsafe.Pointer(&ret))
}

func cVector3Multiply(v1, v2 Vector3) Vector3 {
	cv1 := *(*C.Vector3)(unsafe.Pointer(&v1))
	cv2 := *(*C.Vector3)(unsafe.Pointer(&v2))
	ret := C.Vector3Multiply(cv1, cv2)
	return *(*Vector3)(unsafe.Pointer(&ret))
}

func cVector3Negate(v Vector3) Vector3 {
	cv := *(*C.Vector3)(unsafe.Pointer(&v))
	ret := C.Vector3Negate(cv)
	return *(*Vector3)(unsafe.Pointer(&ret))
}

func cVector3Normalize(v Vector3) Vector3 {
	cv := *(*C.Vector3)(unsafe.Pointer(&v))
	ret := C.Vector3Normalize(cv)
	return *(*Vector3)(unsafe.Pointer(&ret))
}

func cVector3One() Vector3 {
	ret := C.Vector3One()
	return *(*Vector3)(unsafe.Pointer(&ret))
}

func cVector3OrthoNormalize(v1, v2 *Vector3) {
	cv1 := (*C.Vector3)(unsafe.Pointer(v1))
	cv2 := (*C.Vector3)(unsafe.Pointer(v2))
	C.Vector3OrthoNormalize(cv1, cv2)
}

func cVector3Perpendicular(v Vector3) Vector3 {
	cv := *(*C.Vector3)(unsafe.Pointer(&v))
	ret := C.Vector3Perpendicular(cv)
	return *(*Vector3)(unsafe.Pointer(&ret))
}

func cVector3Project(v1, v2 Vector3) Vector3 {
	cv1 := *(*C.Vector3)(unsafe.Pointer(&v1))
	cv2 := *(*C.Vector3)(unsafe.Pointer(&v2))
	ret := C.Vector3Project(cv1, cv2)
	return *(*Vector3)(unsafe.Pointer(&ret))
}

func cVector3Reflect(vector, normal Vector3) Vector3 {
	cvector := *(*C.Vector3)(unsafe.Pointer(&vector))
	cnormal := *(*C.Vector3)(unsafe.Pointer(&normal))
	ret := C.Vector3Reflect(cvector, cnormal)
	return *(*Vector3)(unsafe.Pointer(&ret))
}

func cVector3Refract(v Vector3, n Vector3, r float32) Vector3 {
	cv := *(*C.Vector3)(unsafe.Pointer(&v))
	cn := *(*C.Vector3)(unsafe.Pointer(&n))
	cr := C.float(r)
	ret := C.Vector3Refract(cv, cn, cr)
	return *(*Vector3)(unsafe.Pointer(&ret))
}

func cVector3Reject(v1, v2 Vector3) Vector3 {
	cv1 := *(*C.Vector3)(unsafe.Pointer(&v1))
	cv2 := *(*C.Vector3)(unsafe.Pointer(&v2))
	ret := C.Vector3Reject(cv1, cv2)
	return *(*Vector3)(unsafe.Pointer(&ret))
}

func cVector3RotateByAxisAngle(v Vector3, axis Vector3, angle float32) Vector3 {
	cv := *(*C.Vector3)(unsafe.Pointer(&v))
	caxis := *(*C.Vector3)(unsafe.Pointer(&axis))
	cangle := C.float(angle)
	ret := C.Vector3RotateByAxisAngle(cv, caxis, cangle)
	return *(*Vector3)(unsafe.Pointer(&ret))
}

func cVector3RotateByQuaternion(v Vector3, q Quaternion) Vector3 {
	cv := *(*C.Vector3)(unsafe.Pointer(&v))
	cq := *(*C.Quaternion)(unsafe.Pointer(&q))
	ret := C.Vector3RotateByQuaternion(cv, cq)
	return *(*Vector3)(unsafe.Pointer(&ret))
}

func cVector3Scale(v Vector3, scale float32) Vector3 {
	cv := *(*C.Vector3)(unsafe.Pointer(&v))
	cscale := C.float(scale)
	ret := C.Vector3Scale(cv, cscale)
	return *(*Vector3)(unsafe.Pointer(&ret))
}

func cVector3Subtract(v1, v2 Vector3) Vector3 {
	cv1 := *(*C.Vector3)(unsafe.Pointer(&v1))
	cv2 := *(*C.Vector3)(unsafe.Pointer(&v2))
	ret := C.Vector3Subtract(cv1, cv2)
	return *(*Vector3)(unsafe.Pointer(&ret))
}

func cVector3SubtractValue(v Vector3, sub float32) Vector3 {
	cv := *(*C.Vector3)(unsafe.Pointer(&v))
	csub := C.float(sub)
	ret := C.Vector3SubtractValue(cv, csub)
	return *(*Vector3)(unsafe.Pointer(&ret))
}

func cVector3ToFloatV(v Vector3) [3]float32 {
	cv := *(*C.Vector3)(unsafe.Pointer(&v))
	ret := C.Vector3ToFloatV(cv)
	return *(*[3]float32)(unsafe.Pointer(&ret))
}

func cVector3Transform(v Vector3, mat Matrix) Vector3 {
	cv := *(*C.Vector3)(unsafe.Pointer(&v))
	cmat := *(*C.Matrix)(unsafe.Pointer(&mat))
	ret := C.Vector3Transform(cv, cmat)
	return *(*Vector3)(unsafe.Pointer(&ret))
}

func cVector3Unproject(source Vector3, projection Matrix, view Matrix) Vector3 {
	csource := *(*C.Vector3)(unsafe.Pointer(&source))
	cprojection := *(*C.Matrix)(unsafe.Pointer(&projection))
	cview := *(*C.Matrix)(unsafe.Pointer(&view))
	ret := C.Vector3Unproject(csource, cprojection, cview)
	return *(*Vector3)(unsafe.Pointer(&ret))
}

func cVector3Zero() Vector3 {
	ret := C.Vector3Zero()
	return *(*Vector3)(unsafe.Pointer(&ret))
}

func cWrap(value, min, max float32) float32 {
	cvalue := C.float(value)
	cmin := C.float(min)
	cmax := C.float(max)
	ret := C.Wrap(cvalue, cmin, cmax)
	return float32(ret)
}
